var documenterSearchIndex = {"docs":
[{"location":"Nlayer_cyl/#Light-Diffusion-in-a-N-layered-turbid-cylinder","page":"N-layer Cylinder","title":"Light Diffusion in a N-layered turbid cylinder","text":"","category":"section"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"The salient features and their implementation of Liemert and Kienle's[1] solution to the diffusion equation for the N-layered finite cylinder are discussed. ","category":"page"},{"location":"Nlayer_cyl/#Helpful-Background-Reading:","page":"N-layer Cylinder","title":"Helpful Background Reading:","text":"","category":"section"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Light diffusion in a turbed cylinder. I. Homogoeneous case[2]\nLight diffusion in a turbed cylinder. II. Layered case[1]\nNoninvasive determination of the optical properties of two-layered turbid media[3]\nLight diffusion in N-layered turbid media: steady-state domain[4]\nLight diffusion in N-layered turbid media: frequency and time domains[5]","category":"page"},{"location":"Nlayer_cyl/#Nomenclature:","page":"N-layer Cylinder","title":"Nomenclature:","text":"","category":"section"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"We follow the solution for a point beam incident onto the center top of the first layer of N-layered cylinders with radii a. In cylindrical cooridnates vecr=(rho phi z) the source position can be defined as vecr_0=(00z_0) where z_0 is the assumed position of an isotropic source at a distance z_0 = frac1mu_s1. We ignore the absorption term but if desired can be redefined in the diffusionparams function. The thickness, refractive index, reduced scattering and absorption coefficients of layer k are denoted by l_k n_k mu_s_k mu_a_k, respectively. The extrapolated boundary condition is used with the extrapolation length z_b_k = 2 A_k D_k where A_k reflection factor calculated from the angle-averaged probability for reflection at a boundary between layer k and the surrounding medium. We calculate A_k from the polonomial approximation listed in Contini 1997 but can be calculated in anyway by altering the get_afac function. Finally, the diffusion coefficient in layer k is D_k = 1(3mu_s).","category":"page"},{"location":"Nlayer_cyl/#Solution","page":"N-layer Cylinder","title":"Solution","text":"","category":"section"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"The solution for the fluence in the first layer Phi_1(vecr omega) for a point source incident onto the center of the cylinder top can then be described by Equation 22 in Ref 1. [1]","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Phi_1(vecr) = frac1pi a^2 sum_n=1^infty G_1(s_n z) J_0(s_n rho)J_1^-2(a s_n)","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Where a = a + z_b_k, rho is the source-detector separation, and J_m is the Bessel function of the first kind and order m. More interestingly, s_n are the roots of J_m satisfying J_m(a s_n) = 0qquad n = 1 2 . For an incident source on the center top, the summation over all orders of J_m is no longer needed so we only need to consider m=0. s_n then becomes the roots to Bessel function of the first kind and zero order. It should be noted that both J_0 and J_1 appear in the solution but this is because the general solution is in the form of J_m and J_m+1. For those familiar with the trickier case presented in [3] and then extended in [4] and [5] this is main contribution to the accuracy, stability, and speed of the solutions. For those unfamilar, the decisive point is the numerically correct and efficient 2-D inverse Fourier transform of Phi(z s) must be calculated to obtain the fluence in real space Phi(vecr) (directly taking language from Liemert here). I would say this is most easily implemented by taking advantage of rotational symmetry and using the 1-D inverse Hankel Transform. In contrast, the nodes of the integral are not fixed like in the cylindrical case presented here, but is solved by adaptive Gauss integration. If the nodes were consistent, they could be precomputed and used for each case but the amount of nodes and their location depend on the forward parameters in the model. All this to say, precalculating the roots and storing them is highly efficient and significantly more accurate and stable. The roots are divided by a for each new condition.","category":"page"},{"location":"Nlayer_cyl/#Green's-function","page":"N-layer Cylinder","title":"Green's function","text":"","category":"section"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Finally, the Green's function in the first layer G_1(s_n z) is:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"G_1(s_n z) = frace^-alpha_1 z - z_0 - e^-alpha_1 (z + z_0 + 2z_b_1)2D_1 alpha_1 + fracsinhalpha_1(z_0 + z_b_1) sinhalpha_1(z + z_b_1)D_1alpha_1 e^alpha_1(l_1 + z_b_1) 5pt\ntimes fracD_1alpha_1n_1^2beta_3 - D_2alpha_2n_2^2gamma_3D_1alpha_1n_1^2beta_3coshalpha_1(l_1 + z_b_1) + D_2alpha_2n_2^2gamma_3sinhalpha_1(l_1 + z_b_1)","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Where alpha_k has the form in the steady-state:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"alpha_k = sqrts_n^2 + fracmu_a_kD","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Whereas a complex term is added in the Frequency Domain:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"alpha_k = sqrts_n^2 + fracmu_a_kD + fraciomegaDc","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"As you can notice the first term of G_1(s_n z) contains exponentially decaying functions which is great as you can see that alpha has to be summed for very large numbers. Generally z z_b z_0 are around 0.1 so this is easy to handle computationally. On the other hand, terms like sinhalpha l and coshalpha l go to infinity very quickly. It is much better to define (though messier) the Green's function in terms of exponetials using sinhx = (e^x - e^-x)2 and coshx = (e^x + e^-x)2. After some algebraic manipulation we can then define G_1(s_n z) as:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"G_1(s_n z) = frace^-alpha_1 z - z_0 - e^-alpha_1 (z + z_0 + 2z_b_1)2D_1 alpha_1 + frace^alpha_1(z_0 + z - 2l_1)1 - e^-2alpha_1(z_0 + z_b_1)2D_1alpha_1 5pt\ntimes fracD_1alpha_1n_1^2beta_3 - D_2alpha_2n_2^2gamma_3D_1alpha_1n_1^2beta_31 + e^-2alpha_1(l_1 + z_b_1) + D_2alpha_2n_2^2gamma_31 - e^-2alpha_1(l_1 + z_b_1)","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Great. So now we have expressed the Green's function in terms of exponentially decaying functions instead of dividing by exponentially growing functions so we are confident that we won't get overflow errors as alpha goes to infinity. We are now ready to discuss the last pesky thing which are the gamma_3 and beta_3 factors. These are generally obtained from recurrence relations in [1] by equation 17 and 18. As presented they also contain exponentially growing functions. Where before we only had sinhalpha_1 l_1 now we have exponential functions of all the layers. This is especially challenging if we consider the bottom layer to be large. In general the same procedure we used prior should be used but we can't explicitly write them in terms of decaying functions because these factors actually do exponentially increase. What we can do is take advantage of the way they present in G_1(s_n z) which is (beta_3 - gamma_3)(beta_3 + gamma_3). We need to find a common exponentially growing factor that presents in both coefficients that we can then cancel.","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"After we factor a common term out we can then define the coefficients for an N-layered cylinder as :","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"N = 2:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_3 = 1 - e^-2 alpha_2 (l_2 + z_b_2) 5pt\ngamma_3 = 1 + e^-2 alpha_2 (l_2 + z_b_2)","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"N = 3:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_3 = D_2 alpha_2 n_2^2 (1 + e^-2alpha_2 l_2)(1 - e^-2 alpha_3 (l_3 + z_b_2)) + D_3 alpha_3 n_3^2 (1 - e^-2alpha_2 l_2)(1 + e^-2 alpha_3 (l_3 + z_b_2)) 5pt\ngamma_3 = D_2 alpha_2 n_2^2 (1 - e^-2alpha_2 l_2)(1 - e^-2 alpha_3 (l_3 + z_b_2)) + D_3 alpha_3 n_3^2 (1 + e^-2alpha_2 l_2)(1 + e^-2 alpha_3 (l_3 + z_b_2))","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"N = 4:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_4 = D_3 alpha_3 n_3^2 (1 + e^-2alpha_3 l_3) (1 - e^-2alpha_4 (l_4 + z_b_2) + D_4 alpha_4 n_4^2 (1 - e^-2alpha_3 l_3) (1 + e^-2alpha_4 (l_4 + z_b_2) 5pt\ngamma_4 = D_3 alpha_3 n_3^2 (1 - e^-2alpha_3 l_3) (1 - e^-2alpha_4 (l_4 + z_b_2) + D_4 alpha_4 n_4^2 (1 + e^-2alpha_3 l_3) (1 + e^-2alpha_4 (l_4 + z_b_2) ","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_3 = D_2 alpha_2 n_2^2 beta_4 (1 + e^-2alpha_2 l_2) + D_3 alpha_3 n_3^2 gamma_4 (1 - e^-2alpha_2 l_2) 5pt\ngamma_3 = D_2 alpha_2 n_2^2 beta_4 (1 - e^-2alpha_2 l_2) + D_3 alpha_3 n_3^2 gamma_4 (1 + e^-2alpha_2 l_2)","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"N  4: Use start values","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_N = D_N-1 alpha_N-1 n_n-1^2 (1 + e^-2alpha_N-1l_N-1)(1 - e^-2alpha_N-1(l_N-1 + z_b_2)) 5pt\n + D_N alpha_N n_n^2 (1 - e^-2alpha_N-1l_N-1)(1 + e^-2alpha_N(l_N + z_b_2)) 10pt\ngamma_N = D_N-1 alpha_N-1 n_n-1^2 (1 - e^-2alpha_N-1l_N-1)(1 - e^-2alpha_N-1(l_N-1 + z_b_2)) 5pt\n + D_N alpha_N n_n^2 (1 + e^-2alpha_N-1l_N-1)(1 + e^-2alpha_N(l_N + z_b_2))","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"With downward recurrence relations: ","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_k - 1 = D_k - 2 alpha_k - 2 n_k - 2^2 (1 + e^-2alpha_k - 2l_k - 2) beta_k + D_k - 1 alpha_k - 1 n_k - 1^2 (1 - e^-2alpha_k - 2l_k - 2) gamma_k 5pt\ngamma_k - 1 = D_k - 2 alpha_k - 2 n_k - 2^2 (1 - e^-2alpha_k - 2l_k - 2) beta_k + D_k - 1 alpha_k - 1 n_k - 1^2 (1 + e^-2alpha_k - 2l_k - 2) gamma_k","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"[1]: Liemert, André, and Alwin Kienle. \"Light diffusion in a turbid cylinder. II. Layered case.\" Optics Express 18.9 (2010): 9266-9279.","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"[2]: Liemert, André, and Alwin Kienle. \"Light diffusion in a turbid cylinder. I. Homogeneous case.\" Optics Express 18.9 (2010): 9456-9473.","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"[3]: Kienle, Alwin, et al. \"Noninvasive determination of the optical properties of two-layered turbid media.\" Applied optics 37.4 (1998): 779-791.","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"[4]: Liemert, André, and Alwin Kienle. \"Light diffusion in N-layered turbid media: steady-state domain.\" Journal of biomedical optics 15.2 (2010): 025003.","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"[5]: Liemert, André, and Alwin Kienle. \"Light diffusion in N-layered turbid media: frequency and time domains.\" Journal of biomedical optics 15.2 (2010): 025002.","category":"page"},{"location":"whensemiinf/#*When-is-semi-infinite-semi-infinite?*","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"","category":"section"},{"location":"whensemiinf/#Learning-outcomes:","page":"When is semi-infinite semi-infinite?","title":"Learning outcomes:","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Simulate the time-domain fluence under the diffusion approximation for semi-finite, slab, and parralelepiped geometries\nUtilize the non-linear curve fitting functions to extract optical properties from simulated experimental data\nGain physical intuition of approximations and how to apply them","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"info: Disclaimer\nThe following is not a recommendation on when to apply certain approximations as that would depend on experimental setup and application. Please use this as an introduction to the software.","category":"page"},{"location":"whensemiinf/#Loading-LightPropagation.jl","page":"When is semi-infinite semi-infinite?","title":"Loading LightPropagation.jl","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Let's begin by loading the package into the current environment. This can be done as below or as shown on the main page.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"using LightPropagation","category":"page"},{"location":"whensemiinf/#Forward-Models","page":"When is semi-infinite semi-infinite?","title":"Forward Models","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"The functions we are using to simulate the TPSF for the semi-infinite, slab, and parallelpiped geometries are:","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"fluence_DA_semiinf_TD\nfluence_DA_slab_TD\nfluence_DA_paralpip_TD","category":"page"},{"location":"whensemiinf/#Semi-infinite","page":"When is semi-infinite semi-infinite?","title":"Semi-infinite","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Let's simulate the fluence for a semi-infinite medium under the following conditions in the time-domain:","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"t = 0.01:0.01:5 (ns)\nμa = 0.1 – absorption coefficient (1/cm)\nμsp = 10.0 – reduced scattering coefficient (1/cm)\nρ = 1.0 – source-detector separation (cm)\nn_ext = 1.0 – index of refraction of external medium\nn_med = 1.0 – index of refraction of medium","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"t = 0.01:0.01:5\nsemiinf = fluence_DA_semiinf_TD(t, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0)","category":"page"},{"location":"whensemiinf/#Slab","page":"When is semi-infinite semi-infinite?","title":"Slab","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Let's simulate the time-domain fluence for a slab (bounded in the z-direction) for two thicknesses (2cm and 8cm) with the same optical properties and SDS as simulated for the semi-infinite medium. The inputs are the same as the semi-infinite geometry with an additional input for the slab thickness.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"slab_2cm = fluence_DA_slab_TD(t, 1.0, 0.1, 10.0, s = 2.0) # n_ext and n_med default to 1.0, z defaults to 0.0\nslab_8cm = fluence_DA_slab_TD(t, 1.0, 0.1, 10.0, s = 8.0)","category":"page"},{"location":"whensemiinf/#Parallelepiped","page":"When is semi-infinite semi-infinite?","title":"Parallelepiped","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"The parralelepiped geometry is bounded in the x, y, and z direction. Check the difference in input arguments by typing ? fluence_DA_paralpip_TD into the REPL. You can see that the inputs are slightly different than the slab and semi-infinite geometry. Instead of listing the SDS we need to specify the location of the source and detector in x, y, z coordinates. Here, rd is the x, y, z location of the source on the top surface, and rs is the location of the detector on the top source. These are measured from the corner. Let's have two cubes one with L = 8cm and L = 4cm with the source located in the center so that rs = [4.0, 4.0] and [2.0, 2.0] respectively. We want the detector to be 1cm from the source to match SDS in previous examples. Below they are defined as rd = [3.0, 4.0, 0.0] and [1.0, 2.0, 0.0].        ","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"paralpip_8cm = fluence_DA_paralpip_TD(t, 0.1, 10.0, rd = [3.0, 4.0, 0.0], rs = [4.0,4.0], L = [8.0,8.0,8.0])\nparalpip_4cm = fluence_DA_paralpip_TD(t, 0.1, 10.0, rd = [1.0, 2.0, 0.0], rs = [2.0, 2.0], L = [4.0,4.0,4.0])","category":"page"},{"location":"whensemiinf/#Compare-all-three-geometries","page":"When is semi-infinite semi-infinite?","title":"Compare all three geometries","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Now let's compare and visualize all 5 of the curves we have simulated as shown below:","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"using Plots\nplot(t, semiinf, yscale=:log10, lw = 10, ylabel = \"fluence (1/cm²)\", xlabel = \"time (ns)\", label = \"semiinf\")\nplot!(t, slab_2cm, lw = 2, label = \"lab_2cm\")\nplot!(t, slab_8cm, lw = 4, label = \"slab_8cm\", c=\"black\")\nplot!(t, paralpip_8cm, lw = 2, label = \"paralpip_8cm\", alpha = 0.9)\nplot!(t, paralpip_4cm, lw = 2, label = \"paralpip_4cm\", alpha = 0.9)","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"(Image: modelcomparison)","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Great. Now change the input parameters for each curve (optical properties and SDS) to investigate different domains. Here, for this set of optical properties and SDS the  semi-infinite approximation matches exactly the slab solution when the slab thickness is 8cm (for t < 5ns), though it would be a poor approximation for thin samples (2cm). The parallelepiped geometry also matches the semi-infinite geometry when its sides are greater than 8cm, though there are some differences at longer time scales. In practice, experimental systems would not have enough dynamic range to fit over such large changes in intensity.","category":"page"},{"location":"whensemiinf/#Key-Takeaways","page":"When is semi-infinite semi-infinite?","title":"Key Takeaways","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Good agreement at the earliest times (<1ns) where the boundary effects are minimized. \nFor confined geometries, we see there are significant differences compared to the semi-infinite approximations.\nIf the boundaries are significantly away from the source the semi-infinite approximation appears to be a good approximation.\nIf the underlying media is a parralelepiped, would a semi-infinite geometry under or overestimate the optical properties? Hint: Changes in absorption mainly affect the later times, while scattering dominates early arrival times.","category":"page"},{"location":"whensemiinf/#Inverse-Problem","page":"When is semi-infinite semi-infinite?","title":"Inverse Problem","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Now that we have visually observed the differences between the three geometries, let's investigate and try to quantify the error when using the models in the inverse problem to extract optical properties.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"The first thing we must do is simulate some experimental data to fit. In practice, samples are not infinite so let's use the parralelepiped geometry as the ground 'truth' and let's fit all three models to that curve. You can add noise (follows a poisson distribution) if you would like, but let's assume no noise for now.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"ydata = fluence_DA_paralpip_TD(t, 0.1, 10.0, rd = [0.5, 1.5, 0.0], rs = [1.5, 1.5], L = [3.0, 3.0, 3.0])","category":"page"},{"location":"whensemiinf/#Setup-Inverse-problem","page":"When is semi-infinite semi-infinite?","title":"Setup Inverse problem","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"The first thing we must do is set up the input data and models. See the Inverse Fit tutorial for more information!","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"julia> t_arr = 0.02:0.01:4.0\njulia> ydata = log10.(fluence_DA_paralpip_TD(t_arr, 0.1, 10.0, rd = [0.5, 1.5, 0.0], rs = [1.5, 1.5], L = [3.0, 3.0, 3.0]))\njulia> ub = [1.0, 50.0] # upper bound for [μa, μsp]\njulia> lb = [0.01, 3.0] # lower bound for [μa, μsp]\njulia> p0 = [0.12, 18.2] # some initial guess for our algorithm\n\njulia> model_semiinf(t, β) = log10.(fluence_DA_semiinf_TD(t, ρ, β[1], β[2]))\njulia> model_slab(t, β) = log10.(fluence_DA_slab_TD(t, ρ, β[1], β[2], s = 3.0))\njulia> model_paral(t, β) = log10.(fluence_DA_paralpip_TD(t, β[1], β[2], rd = [0.5, 1.5, 0.0], rs = [1.5, 1.5], L = [3.0, 3.0, 3.0]))\n\njulia> fit_semiinf = curve_fit(model_semiinf, t_arr, ydata, p0, lower=lb, upper=ub)\njulia> fit_slab = curve_fit(model_slab, t_arr, ydata, p0, lower=lb, upper=ub)\njulia> fit_paral = curve_fit(model_paral, t_arr, ydata, p0, lower=lb, upper=ub)","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"scatter(t_arr, ydata, ms = 8, label = \"ydata\", c=\"black\", ylabel = \"fluence (1/cm²)\", xlabel = \"time (ns)\")\nplot!(t_arr, model_paral(t_arr, fit_paral.param), lw = 3, alpha = 1, label = \"paralpip model\", c=\"blue\")\nplot!(t_arr, model_semiinf(t_arr, fit_semiinf.param), lw = 3, alpha = 1,label = \"semiinf model\", c=\"red\")\nplot!(t_arr, model_slab(t_arr, fit_slab.param),lw = 3, alpha = 1, label = \"slab model\", c=\"orange\")","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"(Image: fitcomparison)","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"To check the extracted optical properties we can call the param field of our fit result like:","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"julia> fit_paral.param\n2-element Vector{Float64}:\n  0.1000000000000203\n 10.000000000002833\n\njulia> fit_slab.param\n2-element Vector{Float64}:\n 0.13805160496964075\n 8.432187697059568\n\njulia> fit_semiinf.param\n2-element Vector{Float64}:\n  0.14792469689680052\n 10.222734757205624","category":"page"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Please use the installation section to download and install Julia and LightPropagation.jl. Once downloaded we can open the Julia REPL and type...","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using LightPropagation","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The initial download and compilation could take same time but should only take a couple seconds afterwards. ","category":"page"},{"location":"getting-started/#Forward-Simulation","page":"Getting Started","title":"Forward Simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Let's simulate the steady-state (continuous-wave) fluence from an isotropic point source in an infinite medium using fluence_DA_inf_CW.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> fluence_DA_inf_CW(1.0, 0.1, 10.0)\n0.4223682678487986","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This is a bit confusing because we don't know what 1.0, 0.1, 10.0 represent. To get more information about a function's inputs and methods type ? in the REPL and then the name of the function...","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia>?\nhelp?> fluence_DA_inf_CW\nsearch: fluence_DA_inf_CW fluence_DA_semiinf_CW fluence_DA_inf_TD\n\n  fluence_DA_inf_CW(ρ, μa, μsp)\n\n  Compute the steady-state fluence in an infinite medium.\n\n  Arguments\n  ≡≡≡≡≡≡≡≡≡≡≡\n\n    •  ρ: source-detector separation (cm)\n\n    •  μa: absorption coefficient (cm⁻¹)\n\n    •  μsp: reduced scattering coefficient (cm⁻¹)\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> fluence_DA_inf_CW(1.0, 0.1, 10.0)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This is a convenient way to see a brief description of the function and its arguments. So now in our previous example 1.0 corresponds to ρ which is the source-detector separation in centimeters. 0.1 corresponds to μa which is the absorption coefficient and 10.0 corresponds to μsp which is the reduced scattering coefficient.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If we wanted to simulate this for many ρ values we can do...","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ρ = 0.1:0.1:1.0\n0.1:0.1:1.0\n\njulia> fluence_DA_inf_CW.(ρ, 0.1, 10.0)\n10-element Vector{Float64}:\n 20.076563644369305\n  8.441844991553953\n  4.732864855014603\n  2.985130735997168\n  2.0083126892986254\n  1.4074341205286183\n  1.0145168743692066\n  0.7465266519850676\n  0.5580470079778079\n  0.4223682678487986","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Notice the . after the function call to fluence_DA_inf_CW which implies broadcasting the function over each ρ value. We could also use map...","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> map(ρ -> fluence_DA_inf_CW(ρ, 0.1, 10.0), 0.1:0.1:1.0)\n10-element Vector{Float64}:\n 20.076563644369305\n  8.441844991553953\n  4.732864855014603\n  2.985130735997168\n  2.0083126892986254\n  1.4074341205286183\n  1.0145168743692066\n  0.7465266519850676\n  0.5580470079778079\n  0.4223682678487986","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We can also do this for a single ρ value for several different permutations of μsp and μa with both approaches...","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> fluence_DA_inf_CW.(1.0, [0.1, 0.2], [10.0, 12.1])\n2-element Vector{Float64}:\n 0.4223682678487986\n 0.1952166673254022\n\n julia> map((μa, μsp) -> fluence_DA_inf_CW(1.0, μa, μsp), [0.1, 0.2], [10.0, 12.1])\n2-element Vector{Float64}:\n 0.4223682678487986\n 0.1952166673254022","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The x -> f(x...) creates an anonymous function that can be advantageous when passing functions.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Sometimes we want a computation to be done with higher precision. Take a slightly unrealistic example where we want the fluence way away from the source for large scattering coefficients......","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> fluence_DA_inf_CW(100.0, 1.0, 10000.0)\n0.0","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Well this is slightly unexpected because we wouldn't expect this to be quite 0.0. This is due to using Float64 numbers which have a finite minimum floatmin(Float64) = 2.2250738585072014e-308. We can do this calculation in higher precision by converting one of the inputs to higher precision...","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> fluence_DA_inf_CW(100.0, 1.0, big(10000.0))\n1.502554931959911174198461266529831255882290472488206080785039554131741898622508e-7521\n\njulia> floatmin(BigFloat)\n8.50969131174083613912978790962048280567755996982969624908264897850135431080301e-1388255822130839284","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The previous example works by promoting the types of the other inputs and doing calculations in the higher precision. It is recommended that all inputs be of the same type to make sure some of the calculation isn't done in a lower precision...","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Perhaps we were interested in something slightly more interesting such as the time-domain fluence in a semi-infinite medium...","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> fluence_DA_semiinf_TD(1.0, 1.0, 0.1, 10.0)\n0.000288659079311426","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"More parameters to decipher... let's check the docs!","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"help?> fluence_DA_semiinf_TD\nsearch: fluence_DA_semiinf_TD fluence_DA_semiinf_CW\n\n  fluence_DA_semiinf_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0)\n\n  Compute the time-domain fluence in a semi-infinite medium (Eqn. 33 Contini).\n\n  Arguments\n  ≡≡≡≡≡≡≡≡≡≡≡\n\n    •  t: the time vector (ns).\n\n    •  ρ: the source detector separation (cm⁻¹)\n\n    •  μa: absorption coefficient (cm⁻¹)\n\n    •  μsp: reduced scattering coefficient (cm⁻¹)\n\n    •  n_ext: the boundary's index of refraction (air or detector)\n\n    •  n_med: the sample medium's index of refraction\n\n    •  z: the z-depth in medium\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> fluence_DA_semiinf_TD(0.1:0.1:1.0, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, z = 0.0)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"So now in addition to ρ, μa, μsp we have the t time input. Some of the parameters follow ; symbol meaning they are keyword arguments. We can either explicitly define them with their name...","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> fluence_DA_semiinf_TD(0.1:0.3:1.0, 1.0, 0.1, 10.0, n_ext = 1.0)\n4-element Vector{Float64}:\n 0.13275269870908793\n 0.011700696523308796\n 0.0015494334532460989\n 0.000288659079311426","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Or if they aren't defined they utilize their default value. Notice that we don't need the . here because methods in the time-domain are constructed to more efficiently compute values at many time points. Therefore, there are methods for both t::AbstractFloat and t::AbstractVector.","category":"page"},{"location":"getting-started/#Simple-Plotting","page":"Getting Started","title":"Simple Plotting","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We can compare semi-infinite to slab models in the time domain like the below example...","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> t = 0.01:0.01:4.0; ρ = 1.0; μa = 0.1; μsp = 10.0\njulia> semiinf = fluence_DA_semiinf_TD(t, ρ, μa, μsp)\njulia> slab = fluence_DA_slab_TD(t, ρ, μa, μsp, s = 1.0, xs = 20) # s is the slab thickness\n\njulia> using Plots # make sure to add the Plots package\njulia> plot(t, log10.(semiinf), lw = 2, ylabel = \"fluence (1/cm^2)\", xlabel = \"time (ns)\", label = \"Semi-infinite\")\njulia> plot!(t, log10.(slab), lw = 2, label = \"Slab\")","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"There are several other forward models in different geometries. The naming scheme of the forward models follow a PhysicalQuantity_Approximation_Geometry_MeasurementType scheme. Check out the index below:","category":"page"},{"location":"getting-started/#Index","page":"Getting Started","title":"Index","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"API.md\"]","category":"page"},{"location":"inversefitting/#Inverse-Fitting","page":"Inverse Fitting","title":"Inverse Fitting","text":"","category":"section"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"When dealing with experimental data, we often want to use our forward models in the inverse problem to recover quantitative data from measurements.","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"Here, we will walk through some basic examples to recover optical properties from both steady-state and time-domain measurements.","category":"page"},{"location":"inversefitting/#Steady-State","page":"Inverse Fitting","title":"Steady-State","text":"","category":"section"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"The first thing we want to do is simulate some experimental data. Let's do that by defining our ρ values and true optical properties....","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> using LightPropagation\njulia> ρ_arr = range(0.4, stop = 5.0, length = 10) # define our SDS we want to simulate values for\njulia> μa_true = 0.2; μsp_true = 10.0 # define true optical properties\njulia> ydata = fluence_DA_semiinf_CW.(ρ_arr, μa_true, μsp_true)","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"One unfortunate thing is experiments usually have some noise... Let's use Noise.jl to add some multiplicative white noise with stdev=0.05 and mean=1.0...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> using Noise\njulia> y_noise = mult_gauss(ydata, 0.05, 1.0)","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"Now we are ready to fit. Let's use a standard nonlinear least squares Levenberg-Marquardt algorithm with LsqFit.jl","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"# need to set the bounds in the inverse problem \nub = [1.0, 50.0] # upper bound for [μa, μsp]\nlb = [0.01, 3.0] # lower bound for [μa, μsp]\np0 = [0.12, 18.2] # some initial guess for our algorithm\n\n# set up our model we want to fit with\nmodel(ρ, β) = log10.(fluence_DA_semiinf_CW.(ρ, β[1], β[2]))","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"The previous code block sets up the inverse problem for LsqFit.jl. It would be best to read the docs of LsqFit.jl first. One thing we need to be careful of is properly setting up our model to fit the data. LsqFit needs to know for what xdata it is trying to fit at and for what parameters β it is trying to optimize for. In our case β is an array containing the optical properties β = [μa, μsp] we are seeking. It is also advantageous to fit on a log scale to better normalize the residuals at very high and low fluence values.","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"We are now ready to fit...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> using LsqFit\njulia> fit = curve_fit(model, ρ_arr, log10.(y_noise), p0, lower=lb, upper=ub)\n\n## Let's quickly plot our results\njulia> using Plots\njulia> scatter(ρ_arr, log10.(y_noise), xlabel = \"ρ (cm)\", ylabel = \"ϕ (1/cm²)\", c=:black, label = \"simulated data\", ms=8) # with noise\njulia> plot!(ρ_arr, model(ρ_arr, fit.param), lw = 3, label = \"fit\")\njulia> #plot!(ρ_arr, model(ρ_arr, [μa_true, μsp_true]), label = \"true\") plots the true curve","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"(Image: inversefit_cw)","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"Note that this will take several seconds to run in the beginning due to compile times but will be faster after the first plot. We can call our fit results...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> fit.param\n2-element Vector{Float64}:\n 0.2007638299707845\n 9.95573558637554","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"Sometimes we also want to randomize our initial guess. We could instead define p0 like...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> using Distributions\njulia> p0 = [rand(Uniform(lb[1], ub[1])), rand(Uniform(lb[2], ub[2]))]","category":"page"},{"location":"inversefitting/#Time-Domain","page":"Inverse Fitting","title":"Time-Domain","text":"","category":"section"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"A similar approach in the time-domain can occur except our xdata is now t instead of ρ","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> t_arr = range(0.01, stop = 5.0, length = 500) # define our SDS we want to simulate values for\njulia> μa_true = 0.26; μsp_true = 13.0; ρ = 1.0  # define true optical properties and a single SDS\njulia> ydata = fluence_DA_semiinf_TD(t_arr, ρ, μa_true, μsp_true)","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"Now, the noise in the time-domain for each bin typically follows a poisson distribution...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> using Noise\njulia> y_noise = poisson(log10.(ydata), 500)\n\n# need to set the bounds in the inverse problem \njulia> ub = [1.0, 50.0] # upper bound for [μa, μsp]\njulia> lb = [0.01, 3.0] # lower bound for [μa, μsp]\njulia> p0 = [0.12, 18.2] # some initial guess for our algorithm\n\n# set up our model we want to fit with\njulia> model(t, β) = log10.(fluence_DA_semiinf_TD(t, ρ, β[1], β[2]))","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"We are now ready to fit...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> using LsqFit\njulia> fit = curve_fit(model, t_arr, y_noise, p0, lower=lb, upper=ub)\n\n## Let's quickly plot our results\njulia> using Plots\njulia> scatter(t_arr, y_noise, xlabel = \"ρ (cm)\", ylabel = \"ϕ (1/cm²)\", c=:black, label = \"simulated data\", ms=8) # with noise\njulia> plot!(t_arr, model(t_arr, fit.param), lw = 3, label = \"fit\")","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"(Image: inversefit_td)","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> fit.param\n2-element Vector{Float64}:\n  0.2600394078015929\n 12.913002920897537","category":"page"},{"location":"inversefitting/#Fitting-in-layered-media","page":"Inverse Fitting","title":"Fitting in layered media","text":"","category":"section"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"The principles described previously apply similarly to layered media where we are just increasing the number of parameters we are fitting with. Let's take for example a 2-layer media which yields potential variables of μa1, μa2, μsp1, μsp2, l1, l2. Now, this problem is already significantly more complex than the semi-infinite case when we were fitting for just one parameter. First, let's limit the scope to just fitting the optical properties and assume that the layer thickness are known. We can set up the problem like so...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> t_arr = range(0.05, stop = 2.0, length = 1000)\njulia> ub = [1.0, 1.0, 50.0, 50.0] # upper bound for [μa1, μa2, μsp1, μsp2]\njulia> lb = [0.01, 0.01, 3.0, 3.0] # upper bound for [μa1, μa2, μsp1, μsp2]\njulia> p0 = [0.02, 0.02, 11.0, 11.0] # initial guess for [μa1, μa2, μsp1, μsp2]","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"We can now set up our ydata like the following...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> ρ = 1.0; n_med = [1.0, 1.0]; n_ext = 1.0; a = 5.0; z = 0.0\njulia> μa = [0.01, 0.12]\njulia> μsp = [8.2, 12.8]\njulia> l = [1.0, 4.0]\njulia> ydata = log10.(abs.(fluence_DA_Nlay_cylinder_TD(t_arr, ρ, μa, μsp, n_ext, n_med, l, a, z, besselroots[1:600])))","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"One thing we need to be careful about is the fluence returning a negative value so we take the absolute value here. We can also use structures to pass arguments to the function. The next step is to set up our model but here β must contain an array of all our parameters...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> model(t, β) = log10.(abs.(fluence_DA_Nlay_cylinder_TD(t, ρ, [β[1], β[2]], [β[3], β[4]], n_ext, n_med, l, a, z, besselroots[1:600])))\n## we can then fit as before\njulia> fit = curve_fit(model, t_arr, ydata, p0, lower=lb, upper=ub)","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"And now again we can see how the model did (with no noise)...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> fit.param\n4-element Vector{Float64}:\n  0.010000000000042501\n  0.12000000000000642\n  8.199999999999571\n 12.800000000031716","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"So now let's say we don't know the first layer thickness....","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> t_arr = range(0.05, stop = 2.0, length = 1000)\njulia> ub = [1.0, 1.0, 50.0, 50.0, 4.0] # upper bound for [μa1, μa2, μsp1, μsp2, l1]\njulia> lb = [0.01, 0.01, 3.0, 3.0, 0.4] # upper bound for [μa1, μa2, μsp1, μsp2, l1]\njulia> p0 = [0.02, 0.02, 11.0, 11.0, 2.0] # initial guess for [μa1, μa2, μsp1, μsp2, l1]","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"We can keep the same ydata as before but we must make our model take a fifth parameter like so...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> model(t, β) = log10.(abs.(fluence_DA_Nlay_cylinder_TD(t, ρ, [β[1], β[2]], [β[3], β[4]], n_ext, n_med, [β[5],l[2]], a, z, besselroots[1:600])))\n## we can then fit as before\njulia> fit = curve_fit(model, t_arr, ydata, p0, lower=lb, upper=ub)","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"... and the results","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> fit.param\n5-element Vector{Float64}:\n 0.01\n 0.17771692223609836\n 8.232060952875878\n 3.0\n 1.5090937686394759","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"Unfortunately, this did not produce very good results as this problem is significantly more difficult. We probably need to consider fitting with multiple differnet initial guesses and finding the best fit of those.... Let's try a slightly better guess...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> p0 = [0.013, 0.16, 10.0, 15.0, 1.3]\njulia> fit = curve_fit(model, t_arr, ydata, p0, lower=lb, upper=ub)\njulia> fit.param\n5-element Vector{Float64}:\n 0.01\n 0.12000000000085953\n 8.200000000001857\n 12.799999999834535\n 1.0000000000043645","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"We could also set this up as a general optimization problem like...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> function optim_model(β, t, ydata; ρ = 1.0, l = 10.0, z = 0.0, n_ext = 1.0, n_med = [1.0, 1.0])\n    ymodel = log10.(abs.(fluence_DA_Nlay_cylinder_TD(t, ρ, [β[1], β[2]], [β[3], β[4]], n_ext, n_med, [β[5],l], a, z, besselroots[1:600])))\n\n    return sum((ydata .- ymodel).^2)\nend\n\njulia> using BlackBoxOptim\njulia> bboptimize(β -> optim_model(β, t_arr, ydata), p0; SearchRange = [(0.005, 1.0), (0.01, 1.0), (3.0, 50.0), (3.0, 50.0), (0.4, 4.0)], MaxTime = 60.0, Method = :adaptive_de_rand_1_bin)\nOptimization stopped after 44479 steps and 60.00 seconds\nTermination reason: Max time (60.0 s) reached\nSteps per second = 741.31\nFunction evals per second = 743.03\nImprovements/step = Inf\nTotal function evaluations = 44582\n\n\nBest candidate found: [0.01, 0.220412, 8.17724, 3.0, 1.51944]\n\nFitness: 0.022200604","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"Though, such a naive implementation does not produce great results even after a minute of optimization. ","category":"page"},{"location":"inversefitting/#Automatic-Differentiation","page":"Inverse Fitting","title":"Automatic Differentiation","text":"","category":"section"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"Because we do have access to gradient/jacobian information it is probably best to use it. In the previous examples using LsqFit.jl a central differences technique was utilized to find gradient information, however this can be significantly slower and less accurate. Let's looks at fitting layered solutions in the spatial domain using auto-diff.","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> ρ_arr = range(0.5, stop = 4.0, length = 10)\njulia> ub = [1.0, 1.0, 50.0, 50.0, 4.0] # upper bound for [μa1, μa2, μsp1, μsp2, l1]\njulia> lb = [0.01, 0.01, 3.0, 3.0, 0.4] # upper bound for [μa1, μa2, μsp1, μsp2, l1]\njulia> p0 = [0.02, 0.02, 11.0, 11.0, 2.0] # initial guess for [μa1, μa2, μsp1, μsp2, l1]\njulia> n_med = [1.0, 1.0]; n_ext = 1.0; a = 5.0; z = 0.0\njulia> μa = [0.01, 0.12]\njulia> μsp = [8.2, 12.8]\njulia> l = [1.0, 4.0]\njulia> ydata = log10.(abs.(map(ρ -> fluence_DA_Nlay_cylinder_CW(ρ, μa, μsp, n_ext, n_med, l, a, z, besselroots[1:600]), ρ_arr)))\n\njulia> model(ρ_arr, β) = log10.(abs.((map(ρ -> fluence_DA_Nlay_cylinder_CW(ρ, [β[1], β[2]], [β[3], β[4]], n_ext, n_med, [β[5],l[2]], a, z, besselroots[1:600]), \nρ_arr))))\n## Let's do central difference first\njulia> fit = curve_fit(model, ρ_arr, ydata, p0, lower=lb, upper=ub)\njulia> fit.param\n5-element Vector{Float64}:\n  0.01\n  0.12000000008686881\n  8.200000000444339\n 12.799999996164786\n  1.0000000001194502","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"This interestingly enough produces near exact values with this initial guess... though in a slightly different setup the time-domain struggled to converge. Let's check the time to run the curve fitting...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> @btime fit = curve_fit(model, ρ_arr, ydata, p0, lower=lb, upper=ub)\n  1.961 s (240847 allocations: 102.07 MiB)","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"So this took close to 2 seconds to run. This implementation is rather naive because we are regenerating new fluence values at each SDS from scratch which repeats a lot of similar code. Further optimizing this along with multi-threading could siginificantly decrease this time. Anyway let's see the output and benchmarks when we use autodiff instead for gradient/jacobian information...","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"julia> @btime fit = curve_fit(model, ρ_arr, ydata, p0, lower=lb, upper=ub; autodiff=:forwarddiff)\n  518.778 ms (60068 allocations: 23.80 MiB)julia> fit.param\n5-element Vector{Float64}:\n  0.010000000014621547\n  0.11999999992354275\n  8.199999999622381\n 12.800000003128938\n  0.9999999998932497","category":"page"},{"location":"inversefitting/","page":"Inverse Fitting","title":"Inverse Fitting","text":"So this example take almost half a second which is ~4x faster than the central difference approach. ","category":"page"},{"location":"DA_DCS/#Solutions-of-the-Correlation-Diffusion-Equation","page":"DCS","title":"Solutions of the Correlation Diffusion Equation","text":"","category":"section"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"The following describes how to simulate the autocorrelation function g2 from solutions to the correlation diffusion equation in semi-infinite and layered media. These simulations create a dynamic absorption term from solutions to the diffusion equation to compute the autocorrelation function.","category":"page"},{"location":"DA_DCS/#Semi-infinite","page":"DCS","title":"Semi-infinite","text":"","category":"section"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"To compute the autocorrelation function g2 in a semi-infinite geometry we can use g2_DA_semiinf_CW (click to check docs).","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"This function has four required arguments that must be in order τ, ρ, μa, μsp and six keyword arguments BFi, β, n_ext, n_med, z, λ that can (or not) be defined using a key value.","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"julia> using LightPropagation\n# first define your τ vector on a log scale\njulia> τ = 10 .^(range(-10,stop=0,length=10))\njulia> g2_DA_semiinf_CW(τ, 1.0,0.1, 10.0) # can simulate with default parameters\n10-element Vector{Float64}:\n 1.9999963846836883\n 1.9999533076858178\n 1.999397160946602\n 1.9922498068573495\n 1.9055550839639768\n 1.3239163665819036\n 1.000224562135667\n 1.0\n 1.0\n 1.0","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"Naturally you will want to simulate for more τ values by defining τ = 10 .^(range(-10,stop=0,length=250)). The previous simulation uses the default parameters. We can use keys to define aditional parameters...","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"julia> τ = 10 .^(range(-10,stop=0,length=10))\njulia> g2_DA_semiinf_CW(τ, 1.0,0.1, 10.0, BFi = 1.6e-8, λ = 720.2) # can define BFi, λ\n10-element Vector{Float64}:\n 1.9999972677126077\n 1.9999647118888721\n 1.9995443595433469\n 1.994135632401783\n 1.9275332521385895\n 1.4160741400966292\n 1.0009939892943926\n 1.0000000000000007\n 1.0\n 1.0","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"It sometimes is helpful to use a structure to pass all the arguments. This can be done by defining a structure using DAsemiinf_DCS.","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"Now we can define a structure and use that to quickly simulate g2...","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"julia> τ = 10 .^(range(-10,stop=0,length=10))\njulia> data = DAsemiinf_DCS()\njulia> g2_DA_semiinf_CW(τ, data)\n\n# you can change the arguments of the structure with keys\njulia> data = DAsemiinf_DCS(μsp = 12.1, BFi = 1.2e-8, n_med = 1.2)\njulia> g2_DA_semiinf_CW(τ, data)","category":"page"},{"location":"DA_DCS/#N-layered-cylinder","page":"DCS","title":"N-layered cylinder","text":"","category":"section"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"Layered media follow a similar structure to the semi-infinite case with some more arguments. To compute the autocorrelation function g2 in a N-layered cylinder we can use g2_DA_Nlay_cylinder_CW.","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"This function has four required arguments that must be in order τ, ρ, μa, μsp and nine keyword arguments BFi, β, n_ext, n_med, z, λ, a, l, bessels that can (or not) be defined using a key value.","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"julia> τ = 10 .^(range(-10,stop=0,length=10))\njulia> g2_DA_Nlay_cylinder_CW(τ, 1.0, [0.1, 0.1], [10.0, 10.0], BFi = [2.1e-8, 3.0e-8]) # only define BFi\njulia> g2_DA_Nlay_cylinder_CW(τ, 1.0, [0.1, 0.1], [10.0, 10.0], BFi = [2.1e-8, 3.0e-8], l = [0.8, 3.0]) # define BFi with layer thickness","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"Notice how some of the inputs are now a vector containing the properties of each layer. Here we have a 2 layer media therefore all the vectors have a length 2. If you are using more than 2 layers make sure each vector has the same length and you are explicitly defining all the key values. Generally, you don't need to define bessels as 1000 roots is usually sufficient. You can increase or decrease the number of roots by defining the key bessels = besselroots[1:2000] if you need.","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"Similarly, we can use a structure to define the inputs by using Nlayer_cylinder_DCS.","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"Now we can define a structure and use that to quickly simulate g2.... (will explictly define every input)","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"julia> τ = 10 .^(range(-10,stop=0,length=250))\njulia> ρ = 1.0 # source-detector separation (cm)\njulia> μa = [0.1, 0.1] # absorption coefficient of each layer (1/cm)\njulia> μsp = [10.0, 10.0] # reduced scattering coefficient of each layer (1/cm)\njulia> n_med = [1.0, 1.0] # index of refraction for each layer\njulia> n_ext = 1.0 # index of refraction of external medium (air or detector)\njulia> BFi = [2.0e-8, 2.0e-8] # Blood flow index ~αDb (cm²/s)\njulia> β = 1.0 # scaling factor in Siegert relation\njulia> l = [1.0, 10.0] # thickness of each layer (cm)\njulia> a = 25.0 # radius of cylinder (cm)\njulia> λ = 700.0 # wavelength of light (cm)\njulia> z = 0.0 # depth within medium (cm) (z = 0.0 on top reflecting boudnary)\njulia> data = Nlayer_cylinder_DCS(ρ = ρ, μa = μa, μsp = μsp, n_med = n_med, n_ext = n_ext, β = β, λ = λ, BFi = BFi, z = z, a = a, l = l, bessels = besselroots[1:2000])\n\n# we can now define our correlation times τ\njulia> g2_DA_Nlay_cylinder_CW(τ, data) ","category":"page"},{"location":"DA_DCS/#Comparing-2-layer-to-semi-infinite-solution","page":"DCS","title":"Comparing 2-layer to semi-infinite solution","text":"","category":"section"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"julia> ρ = 1.0\njulia> μa = 0.1\njulia> μsp = 10.0\njulia> τ = 10 .^(range(-10,stop=0,length=250))\n\njulia> si = g2_DA_semiinf_CW(τ, ρ, μa, μsp, BFi = 2e-8)\n\njulia> layered = g2_DA_Nlay_cylinder_CW(τ, ρ, [0.1, 0.1], [10.0, 10.0], BFi = [2.0e-8, 2.0e-8], l = [0.5, 10.0])\njulia> layered2 = g2_DA_Nlay_cylinder_CW(τ, ρ, [0.1, 0.1], [10.0, 10.0], BFi = [2.0e-8, 5.0e-8], l = [0.5, 10.0])\njulia> layered3 = g2_DA_Nlay_cylinder_CW(τ, ρ, [0.1, 0.1], [10.0, 10.0], BFi = [5.0e-8, 2.0e-8], l = [0.5, 10.0])\n\njulia> using Plots # need to add this package\njulia> scatter(log10.(τ), si, label = \"Semi-inf - BFi = 2e-8 cm²/s\", ylabel = \"g2(τ)\", xlabel = \"log(τ (s))\")\njulia> plot!(log10.(τ), layered, label = \"Layered - BFi = [2e-8, 2e-8] cm²/s\", lw = 1.5, linecolor =:black)\njulia> plot!(log10.(τ), layered2, label = \"Layered - BFi = [2e-8, 5e-8] cm²/s\", linestyle=:dash, lw = 1.5, linecolor =:red)\njulia> plot!(log10.(τ), layered3, label = \"Layered - BFi = [5e-8, 2e-8] cm²/s\", linestyle=:dot, lw = 1.5, linecolor =:blue4)","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"(Image: dcs_lay_comparison)","category":"page"},{"location":"DA_DCS/","page":"DCS","title":"DCS","text":"At this point, change the optical properties and parameters to see how the solutions differ.","category":"page"},{"location":"DA_slab_semiinfgeom/#Solutions-of-the-Diffusion-Equation-for-the-Slab-Geometry","page":"Slab","title":"Solutions of the Diffusion Equation for the Slab Geometry","text":"","category":"section"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"The following describes the light propagation through turbid media bounded by parallel planes. ","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"The described derivations follow the methods from Contini 1997.[1]","category":"page"},{"location":"DA_slab_semiinfgeom/#Diffusion-Equation","page":"Slab","title":"Diffusion Equation","text":"","category":"section"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"(frac1nufracpartial partial t - Dnabla^2 + mu_a)Phi(vecr t) = Q(vecr t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Where Q(vecr t) is the isotropic source term and D is the diffusion coefficient, D = frac13mu_s","category":"page"},{"location":"DA_slab_semiinfgeom/#Solution-of-the-Diffusion-Equation-for-homogeneous-media-in-a-slab-geometry","page":"Slab","title":"Solution of the Diffusion Equation for homogeneous media in a slab geometry","text":"","category":"section"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"The diffusion equation is a partial-differential equation that will require boundary conditions to solve for a specific geometry. Here we will utilize the extrapolated boundary conditions as described in Contini 1997.[1] that assumes that the flux is equal to 0 on an extrapolated surface at a distance of (2AD). After the boundary conditions have been determined, utilizng the method of images will allow us to reconstruct the fluence inside the medium. ","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Utilizing Equation 33 from Contini 1997,[1] the time-dependent Green's function for the fluence rate at (vecr) can be described by:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Phi(vecr t) = fracnu(4pi D nu t)^frac32\nexp(- fracrho ^24 D nu t - mu_a nu t) times\nsum_m=-infty^m=+infty exp(-frac(z-z_m^+)^24 D nu t) - \nexp(-frac(z-z_m^-)^24 D nu t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Where:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"z_m^+ = 2m(s+ 2z_e)\nz_m^- = 2m(s +2z_e) - 2z_e - z_s\nm = 0 pm 1 pm 2  pm infty","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"To obtain solutions for the time-dependent transmittance and reflectance we can utilize Fick's law where:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"R (rho t) = Dfracpartialpartial z Phi(rho z = 0 t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"and ","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"T (rho t) = - Dfracpartialpartial z Phi(rho z = s t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Which yields Equation 36 from Contini 1997[1] for the time-dependent reflectance on the surface:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"R(rho t) = - fracexp(-mu_a nu t - fracrho^24 D nu t)2(4pi D nu)^frac32t^frac52\ntimes\nsum_m=-infty^m=+infty z_3mexp(-fracz_3m^24 D nu t) - \nz_4mexp(-fracz_4m^24 D nu t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"and Equation 39 from Contini 1997.[1] for the time-dependent transmittance on at the distance z=s where s is the thickness of the slab:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"T(rho t) = fracexp(-mu_a nu t - fracrho^24 D nu t)2(4pi D nu)^frac32t^frac52\ntimes\nsum_m=-infty^m=+infty z_1mexp(-fracz_1m^24 D nu t) - \nz_2mexp(-fracz_2m^24 D nu t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Where:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"z_1m = s(1-2m) - 4mz_e - z_o\nz_2m = s(1-2m) - (4m-2)z_e - z_o\nz_3m = -2ms - 4mz_e - z_o\nz_4m = -2ms - (4m-2)z_e - z_o","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"[1]: Daniele Contini, Fabrizio Martelli, and Giovanni Zaccanti, \"Photon migration through a turbid slab described by a model based on diffusion approximation. I. Theory,\" Appl. Opt. 36, 4587-4599 (1997) ","category":"page"},{"location":"install/#Installation-Instructions","page":"Installation","title":"Installation Instructions","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Install Julia by downloading the latest version from the offical site and following the platform specific installations.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"LightPropagation is not yet a registered Julia package in the official entry, though we still recommend installing it with the built-in Julia package manager. It automatically installs a currently stable and tagged release. From the Julia REPL (accessed by pressing ] in the Julia REPL command prompt), you can add the package:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia>]\n(@v1.6) pkg> add \"https://github.com/heltonmc/LightPropagation.jl.git\"","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"LightPropagation.jl is only tested on Julia v1.5 and later. The package is under rapid development and breaking changes to the user API do occur, so update with care. Please open an issue if something breaks or doesn't seem right!","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"After adding the package, we can load it with using which will load the module and make its exported names availabe for direct use.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using LightPropagation","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Throughout the rest of the documenation and examples we will assume that the package has been added and have already typed using LightPropagation in the Julia REPL.","category":"page"},{"location":"install/#Updating-to-latest-version","page":"Installation","title":"Updating to latest version","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If desired, you can also check the version of LightPropagation.jl that you have installed with the status command in the package manager...","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> ]\n(@v1.6) pkg> status LightPropagation\n      Status `~/.julia/environments/v1.6/Project.toml`\n  [bd080553] LightPropagation v0.4.3 `https://github.com/heltonmc/LightPropagation.jl.git#main`","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"LightPropagation.jl can be updated to the latest tagged release from the package manager by typing...","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(@v1.6) pkg> update LightPropagation","category":"page"},{"location":"#LightPropagation.jl","page":"Home","title":"LightPropagation.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LighPropagation provides a set of tools for modeling light transport in turbid media written in the Julia programming language. The main motivation behind the development of this library is to provide an easy-to-use, open-source framework that highlights and standardizes prominent analytical techniques to model light transport in different geometries. The radiative transport equation (RTE) and its approximations to model propagation of particles in random media are frequently applied in astrophysics, nuclear physics, biophotonics, heat transfer, computer graphics, and climate research. This package focuses on their use in biomedical applications with a focus on performance and accuracy.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The library has two main components split into (a) the forward modelling of light transport and (b) the associated inverse problem. Currently, photon migration in the continuous-wave (CW), frequency-domain (FD) and time-domain (TD) under the Diffusion Approximation (DA) are described in homogenous media for infinite, semi-infinite, slab, and parallelepiped geometries and for heterogenous media in the case of layered cylinders. Least squares fitting based on the Levenberg-Marquardt algorithm are also available to fit time-resolved measurements after convolution with the Instrument Response Function (IRF). ","category":"page"},{"location":"#Julia-educational-resources","page":"Home","title":"Julia educational resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in learning Julia (definitely encouraged!) here are some resources. In general, only a basic knowledge of the language is needed to use LightPropagation.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Official documentation\nList of learning resources\nYouTube","category":"page"},{"location":"#How-to-get-help?","page":"Home","title":"How to get help?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in using LightPropagation.jl or are trying to figure out how to use it, please feel free to get in touch and raise questions. Do open an issue or pull request if you have questions, suggestions or solutions. Start a new discussion for a more informal discussion!","category":"page"},{"location":"API/#Diffusion-Approximation","page":"API","title":"Diffusion Approximation","text":"","category":"section"},{"location":"API/#Infinite","page":"API","title":"Infinite","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"fluence_DA_inf_CW\nfluence_DA_inf_TD","category":"page"},{"location":"API/#LightPropagation.fluence_DA_inf_CW","page":"API","title":"LightPropagation.fluence_DA_inf_CW","text":"fluence_DA_inf_CW(ρ, μa, μsp)\n\nCompute the steady-state fluence in an infinite medium.\n\nArguments\n\nρ: source-detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nExamples\n\njulia> fluence_DA_inf_CW(1.0, 0.1, 10.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.fluence_DA_inf_TD","page":"API","title":"LightPropagation.fluence_DA_inf_TD","text":"fluence_DA_inf_TD(t, ρ, μa, μsp; n_med = 1.0)\n\nCompute the time-domain fluence in an infinite medium.\n\nArguments\n\nt: the time vector (ns). \nρ: source-detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nKeyword Arguments\n\nn_med= 1.0: medium's index of refraction\n\nExamples\n\njulia> fluence_DA_inf_TD(0.1, 1.0, 0.1, 10.0, n_med = 1.4)\njulia> fluence_DA_inf_TD(0.1:0.5:5.0, 1.0, 0.1, 10.0, n_med = 1.4)\n\n\n\n\n\n","category":"function"},{"location":"API/#Semi-infinite","page":"API","title":"Semi-infinite","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"fluence_DA_semiinf_CW\nfluence_DA_semiinf_TD\nflux_DA_semiinf_CW\nflux_DA_semiinf_TD","category":"page"},{"location":"API/#LightPropagation.fluence_DA_semiinf_CW","page":"API","title":"LightPropagation.fluence_DA_semiinf_CW","text":"fluence_DA_semiinf_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0)\n\nCompute the steady-state fluence in a semi-infinite geometry.\n\nArguments\n\nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nKeyword arguments\n\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nz: the z-depth orthogonal from the boundary (cm)\n\nExamples\n\njulia> fluence_DA_semiinf_CW(1.0, 0.1, 10.0)\njulia> fluence_DA_semiinf_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, z = 0.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.fluence_DA_semiinf_TD","page":"API","title":"LightPropagation.fluence_DA_semiinf_TD","text":"fluence_DA_semiinf_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0)\n\nCompute the time-domain fluence in a semi-infinite medium.  \n\nArguments\n\nt: the time vector (ns). \nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nKeyword arguments\n\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nz: the z-depth orthogonal from the boundary (cm)\n\nExamples\n\njulia> fluence_DA_semiinf_TD(0.1:0.1:2.0, 1.0, 0.1, 10.0)\njulia> fluence_DA_semiinf_TD(0.2:0.2:1.0, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, z = 0.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_semiinf_CW","page":"API","title":"LightPropagation.flux_DA_semiinf_CW","text":"flux_DA_semiinf_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0)\n\nCompute the steady-state flux (D*∂ϕ(ρ)/∂z @ z = 0) from a semi-infinite medium.\n\nArguments\n\nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nKeyword arguments\n\nndet: the boundary's index of refraction (air or detector)\nnmed: the sample medium's index of refraction\n\nExamples\n\njulia> flux_DA_semiinf_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_semiinf_TD","page":"API","title":"LightPropagation.flux_DA_semiinf_TD","text":"flux_DA_semiinf_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0)\n\nCompute the time-domain flux (D*∂ϕ(t)/∂z @ z = 0) in a semi-infinite medium.\n\nArguments\n\nt: the time vector (ns). \nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nKeyword arguments\n\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\n\nExamples\n\njulia> flux_DA_semiinf_TD(0.1:0.1:2.0, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#Slab","page":"API","title":"Slab","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"fluence_DA_slab_CW\nfluence_DA_slab_TD\nflux_DA_slab_CW\nflux_DA_slab_TD","category":"page"},{"location":"API/#LightPropagation.fluence_DA_slab_CW","page":"API","title":"LightPropagation.fluence_DA_slab_CW","text":"fluence_DA_slab_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 2.0, z = 0.0, xs = 10)\n\nCompute the steady-state fluence from a slab geometry (x, y -> inf, z -> finite). The fluence is calculated from an infinite summation that converges rather rapidly. Generally only 5 terms are needed (xs = 5), but more terms will be required if ρ >> s.\n\nArguments\n\nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nOptional arguments\n\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\ns: the thickness (z-depth) of the slab (cm)\nz: the z-depth within slab (cm)\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> fluence_DA_slab_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0)\n\n\n\n\n\nfluence_DA_slab_CW(data::DiffusionParameters)\n\nWrapper to fluence_DA_slab_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0, s = 1.0, xs = 10)\n\nExamples\n\njulia> data = DAslab(ρ = 1.0, s = 3.0) # use structure to generate inputs\njulia> fluence_DA_slab_CW(data) # then call the function\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.fluence_DA_slab_TD","page":"API","title":"LightPropagation.fluence_DA_slab_TD","text":"fluence_DA_slab_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0, xs = 10)\n\nCompute the time-domain fluence from a slab geometry (x, y -> inf, z -> finite). The fluence is calculated from an infinite summation that converges rather rapidly. Generally only 5 terms are needed (xs = 5), but more terms will be required if ρ >> s. At long time values (low fluence values), the solution struggles with limited precision. Using double floats or BigFloats is advised at these times.\n\nArguments\n\nt: the time vector (ns). \nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nOptional arguments\n\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\ns: the thickness (z-depth) of the slab (cm)\nz: the z-depth coordinate (cm)\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> fluence_DA_slab_TD(0.1, 1.0, 0.1, 10.0, s = 40.0)\n\n\n\n\n\nfluence_DA_slab_TD(t, data::DiffusionParameters)\n\nWrapper to fluence_DA_slab_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0, xs = 10)\n\nExamples\n\njulia> data = DAslab() # use structure to generate inputs\njulia> fluence_DA_slab_TD(data) # then call the function\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_slab_CW","page":"API","title":"LightPropagation.flux_DA_slab_CW","text":"fluence_DA_slab_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 2.0, z = 0.0, xs = 10)\n\nCompute the steady-state flux, D∂ϕ(ρ)/∂z for z = 0 and -D∂ϕ(ρ)/∂z for z = s from a slab geometry (x, y -> inf, z -> finite). If z != 0 or s will default to compute D*∂ϕ(ρ)/∂z for the z given.\n\nArguments\n\nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nOptional arguments\n\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\ns: the thickness (z-depth) of the slab (cm)\nz: the z-depth within slab (cm)\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> flux_DA_slab_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, s = 2.0, z = 0.0)\n\n\n\n\n\nflux_DA_slab_CW(data::DiffusionParameters)\n\nWrapper to flux_DA_slab_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0)\n\nExamples\n\njulia> data = DAslab(ρ = 1.0) # use structure to generate inputs\njulia> flux_DA_slab_CW(data) # then call the function\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_slab_TD","page":"API","title":"LightPropagation.flux_DA_slab_TD","text":"flux_DA_slab_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0, xs = 15)\n\nCompute the time-domain flux, D*∂ϕ(t)/∂z for z = 0 and -D*∂ϕ(t)/∂z for z = s from a slab geometry (x, y -> inf, z -> finite).\nIf z != 0 or s will default to compute D*∂ϕ(t)/∂z for the z given.\n\nArguments\n\nt: the time vector (ns). \nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nKeyword arguments\n\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\ns: the thickness (z-depth) of the slab (cm)\nz: the z-depth coordinate (cm) must be equal\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> flux_DA_slab_TD(1.0, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, z = 0.0, s = 1.0)\n\n\n\n\n\nflux_DA_slab_TD(t, data::DiffusionParameters)\n\nWrapper to flux_DA_slab_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0, s = 1.0, xs = 15)\n\nExamples\n\njulia> data = DAslab(ρ = 1.0) # use structure to generate inputs\njulia> flux_DA_slab_TD(data) # then call the function\n\n\n\n\n\n","category":"function"},{"location":"API/#Parallelepiped","page":"API","title":"Parallelepiped","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"fluence_DA_paralpip_CW\nfluence_DA_paralpip_TD","category":"page"},{"location":"API/#LightPropagation.fluence_DA_paralpip_CW","page":"API","title":"LightPropagation.fluence_DA_paralpip_CW","text":"fluence_DA_paralpip_CW(μa, μsp; n_ext = 1.0, n_med = 1.0, rd = [4.0, 5.0, 0.0], rs = [5.0, 5.0], L = [10.0, 10.0, 10.0], xs = 10)\n\nCompute the steady-state fluence in a parallelepiped [lx, ly, lz].\n\nArguments\n\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nOptional arguments\n\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nrd: target location within medium [x,y,z] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0\nrs: the location of the source [x,y] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0\nL: the dimensions [lx, ly, lz] of the parallelepiped\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> fluence_DA_paralpip_CW(0.1, 10.0, n_ext = 1.0, n_med = 1.0, rd = [24.0, 25.0, 0.0], rs = [25.0,25.0], L = [50.0,50.0,50.0], xs = 20)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.fluence_DA_paralpip_TD","page":"API","title":"LightPropagation.fluence_DA_paralpip_TD","text":"fluence_DA_paralpip_TD(t, μa, μsp; n_ext = 1.0, n_med = 1.0, rd = [4.0, 5.0, 0.0], rs = [5.0, 5.0], L = [10.0, 10.0, 10.0], xs = 10)\n\nCompute the time-domain fluence in a parallelepiped [lx, ly, lz].\n\nArguments\n\nt: the time vector (ns). \nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nOptional arguments\n\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nrd: target location within medium [x,y,z] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0\nrs: the location of the source [x,y] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0\nL: the dimensions [lx, ly, lz] of the parallelepiped\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> fluence_DA_paralpip_TD(0.5, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, rd = [24.0, 25.0, 0.0], rs = [25.0,25.0], L = [50.0,50.0,50.0], xs = 20)\n\n\n\n\n\n","category":"function"},{"location":"API/#Layered-Cylinder","page":"API","title":"Layered Cylinder","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"fluence_DA_Nlay_cylinder_CW\nfluence_DA_Nlay_cylinder_TD\n\nflux_DA_Nlay_cylinder_CW\nflux_DA_Nlay_cylinder_TD","category":"page"},{"location":"API/#LightPropagation.fluence_DA_Nlay_cylinder_CW","page":"API","title":"LightPropagation.fluence_DA_Nlay_cylinder_CW","text":"fluence_DA_Nlay_cylinder_CW(ρ, μa, μsp; n_ext=1.0, n_med=(1.0, 1.0), l=(1.0, 5.0), a=10.0, z=0.0, MaxIter=10000, atol=eps(Float64))\n\nCompute the steady-state fluence in an N-layered cylinder.\n\nArguments\n\nρ::Union{T, NTuple{M, T}}: source-detector separation(s) in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)\nμa::NTuple{N, T}: absorption coefficients in each layer (cm⁻¹)\nμsp::NTuple{N, T}: reduced scattering coefficient in each layer (cm⁻¹)\n\nKeyword arguments\n\nn_ext::T: the boundary's index of refraction (air or detector)\nn_med::NTuple{N, T}: the sample medium's index of refraction in each layer\nz::T: the z-depth orthogonal from the boundary (cm) within the cylinder\nl::NTuple{N, T}: layer thicknesses (cm)\na::T: cylinder radius (cm)\nMaxIter::Int: the maximum number of terms to consider in the infinite sum\natol::T: the infinite sum will break after this absolute tolerance is met\n\nThe source must be located in the first layer (l[1] > 1/μsp[1]). Other arguments are not checked but should be restricted to:\n\nρ, μa, and z >= 0.0\nμsp, next, nmed, a > 0.0\nl .> 0.0\nρ < a\nlength(μa) == length(μsp) == length(n_med) == length(l)\n\nρ can be a single source detector separation or a tuple of separations. μa, μsp, n_med, l should be tuples of the same length (e.g., (0.1, 0.1)).  The input parameters should be of the same type, but will work with mixed types.  The routine can be accurate until the machine precision used in the calculation.  Therefore, atol should be >= eps(T). Larger values of μsp[1] will require a larger number of terms in the summation. It is recommended to increase MaxIter if simulating higher scattering coefficients. It is also recommended to keep the cylinder radius as small as  possible to increase convergence rate.  \n\nExamples\n\njulia> fluence_DA_Nlay_cylinder_CW(1.0, (0.1, 0.1), (10.0, 10.0))\njulia> fluence_DA_Nlay_cylinder_CW((1.0, 2.0), (0.1, 0.1), (10.0, 10.0))\njulia> fluence_DA_Nlay_cylinder_CW(1.0, (0.2, 0.1), (12.0, 10.0), l = (10.0, 10.0), MaxIter=1000, atol=1.0e-8)\n# to simulate a 3 layer media\njulia> fluence_DA_Nlay_cylinder_CW(1.0, (0.2, 0.1, 0.2), (12.0, 10.0, 11.0), l = (1.0, 1.2, 4.0), n_med = (1.0, 1.0, 1.0), MaxIter=1000, atol=1.0e-8)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.fluence_DA_Nlay_cylinder_TD","page":"API","title":"LightPropagation.fluence_DA_Nlay_cylinder_TD","text":"fluence_DA_Nlay_cylinder_TD(t, ρ, μa, μsp; n_ext=1.0, n_med=(1.0, 1.0), l=(1.0, 5.0), a=10.0, z=0.0, MaxIter=10000, atol=eps(Float64), N, ILT)\n\nCompute the time-domain fluence in an N-layered cylinder.\n\nArguments\n\nt::Union{T, Vector{T}}: time point or vector of time values (ns)\nρ::Union{T}: source-detector separation in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)\nμa::NTuple{N, T}: absorption coefficients in each layer (cm⁻¹)\nμsp::NTuple{N, T}: reduced scattering coefficient in each layer (cm⁻¹)\n\nKeyword arguments\n\nn_ext::T: the boundary's index of refraction (air or detector)\nn_med::NTuple{N, T}: the sample medium's index of refraction in each layer\nz::T: the z-depth orthogonal from the boundary (cm) within the cylinder\nl::NTuple{N, T}: layer thicknesses (cm)\na::T: cylinder radius (cm)\nMaxIter::Int: the maximum number of terms to consider in the infinite sum\natol::T: the infinite sum will break after this absolute tolerance is met\nN::Int: the number of terms used in the integration of the trapezoidal rule for the Laplace transform\nILT: fucntion used to perform the inverse Laplace transform\n\nThe source must be located in the first layer (l[1] > 1/μsp[1]). Other arguments are not checked but should be restricted to:\n\nρ, μa, and z >= 0.0\nμsp, next, nmed, a > 0.0\nl .> 0.0\nρ < a\nlength(μa) == length(μsp) == length(n_med) == length(l)\nt .> 0.0\n\nt can be a scaler or a vector but all values of t should be greater than zero and if a vector, should be ordered. If t is a scaler hyperbola is used for  the inverse Laplace transform where hyper_fixed is used if it is a vector. The value of N should be proportional to the dynamic range of the time-domain signal needed. If t[end]/t[1] is large then a higher value of N will be required. In general, a larger N will be needed to reconstruct very late times.  μa, μsp, n_med, l should be tuples of the same length (e.g., (0.1, 0.1)). The input parameters should be of the same type, but will work with mixed types.  The routine can be accurate until the machine precision used in the calculation.  Therefore, atol should be >= eps(eltype(μsp)). Larger values of μsp[1] will require a larger number of terms in the summation. It is recommended to increase MaxIter if simulating higher scattering coefficients. It is also recommended to keep the cylinder radius as small as  possible to increase convergence rate.\n\nThe Laplace transform implements threaded parallelism. It is recommended to start Julia with multiple threads (check with Threads.nthreads() in the REPL)\n\nExamples\n\n# at a single time point\njulia> fluence_DA_Nlay_cylinder_TD(1.0, 1.0, (0.1, 0.1), (10.0, 10.0))\n# for several time points\njulia> fluence_DA_Nlay_cylinder_TD(0.2:0.2:2.0, 1.0, (0.1, 0.1), (10.0, 10.0))\njulia> fluence_DA_Nlay_cylinder_TD([0.5, 0.8, 1.2], 1.0, (0.1, 0.1), (10.0, 10.0))\njulia> fluence_DA_Nlay_cylinder_TD(0.1:0.3:5.0, 1.0, (0.1, 0.2), (12.0, 10.0), N = 48)\n# to simulate a 3 layer media\njulia> fluence_DA_Nlay_cylinder_TD(0.1:0.2:1.2, 1.0, (0.2, 0.1, 0.2), (12.0, 10.0, 11.0), l = (1.0, 1.2, 4.0), n_med = (1.0, 1.0, 1.0), MaxIter=1000, atol=1.0e-8)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_Nlay_cylinder_CW","page":"API","title":"LightPropagation.flux_DA_Nlay_cylinder_CW","text":"flux_DA_Nlay_cylinder_CW(ρ, μa, μsp; n_ext=1.0, n_med=(1.0, 1.0), l=(1.0, 5.0), a=10.0, z=0.0, MaxIter=10000, atol=eps(Float64))\n\nCompute the steady-state flux using Fick's law D[1]∂ϕ(ρ)/∂z for z = 0 (reflectance) and -D[end]∂ϕ(ρ)/∂z for z = sum(l) (transmittance) in an N-layered cylinder. z must be equal to 0 or the total length sum(l) of cylinder.\n\nArguments\n\nρ::Union{T}: source-detector separation in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)\nμa::NTuple{N, T}: absorption coefficients in each layer (cm⁻¹)\nμsp::NTuple{N, T}: reduced scattering coefficient in each layer (cm⁻¹)\n\nKeyword arguments\n\nn_ext::T: the boundary's index of refraction (air or detector)\nn_med::NTuple{N, T}: the sample medium's index of refraction in each layer\nz::T: the z-depth orthogonal from the boundary (cm) within the cylinder\nl::NTuple{N, T}: layer thicknesses (cm)\na::T: cylinder radius (cm)\nMaxIter::Int: the maximum number of terms to consider in the infinite sum\natol::T: the infinite sum will break after this absolute tolerance is met\n\nThe source must be located in the first layer (l[1] > 1/μsp[1]). Other arguments are not checked but should be restricted to:\n\nρ, μa, and z >= 0.0\nμsp, next, nmed, a > 0.0\nl .> 0.0\nρ < a\nlength(μa) == length(μsp) == length(n_med) == length(l)\n\nρ can be a single source detector separation, however there is currently a bug in the code preventing this https://github.com/heltonmc/LightPropagation.jl/issues/11.  μa, μsp, n_med, l should be tuples of the same length (e.g., (0.1, 0.1)). The input parameters should be of the same type, but will work with mixed types.  The routine can be accurate until the machine precision used in the calculation.  Therefore, atol should be >= eps(eltype(μsp)). Larger values of μsp[1] will require a larger number of terms in the summation. It is recommended to increase MaxIter if simulating higher scattering coefficients. It is also recommended to keep the cylinder radius as small as  possible to increase convergence rate.  \n\nExamples\n\njulia> flux_DA_Nlay_cylinder_CW(1.0, (0.1, 0.1), (10.0, 10.0))\njulia> flux_DA_Nlay_cylinder_CW((1.0, 2.0), (0.1, 0.1), (10.0, 10.0))\njulia> flux_DA_Nlay_cylinder_CW(1.0, (0.2, 0.1), (12.0, 10.0), l = (10.0, 10.0), MaxIter=1000, atol=1.0e-8)\n# to simulate a 3 layer media\njulia> flux_DA_Nlay_cylinder_CW(1.0, (0.2, 0.1, 0.2), (12.0, 10.0, 11.0), l = (1.0, 1.2, 4.0), n_med = (1.0, 1.0, 1.0), MaxIter=1000, atol=1.0e-8)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_Nlay_cylinder_TD","page":"API","title":"LightPropagation.flux_DA_Nlay_cylinder_TD","text":"flux_DA_Nlay_cylinder_TD(t, ρ, μa, μsp; n_ext=1.0, n_med=(1.0, 1.0), l=(1.0, 5.0), a=10.0, z=0.0, MaxIter=10000, atol=eps(Float64), N, ILT)\n\nCompute the time-domain flux using Fick's law D[1]∂ϕ(ρ, t)/∂z for z = 0 (reflectance) and -D[end]∂ϕ(ρ, t)/∂z for z = sum(l) (transmittance) in an N-layered cylinder. ∂ϕ(ρ, t)/∂z is calculated using forward mode auto-differentiation with ForwardDiff.jl\n\nArguments\n\nt::Union{T, Vector{T}}: time point or vector of time values (ns)\nρ::Union{T}: source-detector separation in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)\nμa::NTuple{N, T}: absorption coefficients in each layer (cm⁻¹)\nμsp::NTuple{N, T}: reduced scattering coefficient in each layer (cm⁻¹)\n\nKeyword arguments\n\nn_ext::T: the boundary's index of refraction (air or detector)\nn_med::NTuple{N, T}: the sample medium's index of refraction in each layer\nz::T: the z-depth orthogonal from the boundary (cm) within the cylinder\nl::NTuple{N, T}: layer thicknesses (cm)\na::T: cylinder radius (cm)\nMaxIter::Int: the maximum number of terms to consider in the infinite sum\natol::T: the infinite sum will break after this absolute tolerance is met\nN::Int: the number of terms used in the integration of the trapezoidal rule for the Laplace transform\nILT: fucntion used to perform the inverse Laplace transform\n\nThe source must be located in the first layer (l[1] > 1/μsp[1]). Other arguments are not checked but should be restricted to:\n\nρ, μa, and z >= 0.0\nμsp, next, nmed, a > 0.0\nl .> 0.0\nρ < a\nlength(μa) == length(μsp) == length(n_med) == length(l)\nt .> 0.0\n\nt can be a scaler or a vector but all values of t should be greater than zero and if a vector, should be ordered. If t is a scaler hyperbola is used for  the inverse Laplace transform where hyper_fixed is used if it is a vector. The value of N should be proportional to the dynamic range of the time-domain signal needed. If t[end]/t[1] is large then a higher value of N will be required. In general, a larger N will be needed to reconstruct very late times.  μa, μsp, n_med, l should be tuples of the same length (e.g., (0.1, 0.1)). The input parameters should be of the same type, but will work with mixed types.  The routine can be accurate until the machine precision used in the calculation.  Therefore, atol should be >= eps(T). Larger values of μsp[1] will require a larger number of terms in the summation. It is recommended to increase MaxIter if simulating higher scattering coefficients. It is also recommended to keep the cylinder radius as small as  possible to increase convergence rate.\n\nThe Laplace transform implements threaded parallelism. It is recommended to start Julia with multiple threads (check with Threads.nthreads() in the REPL)\n\nExamples\n\n# at a single time point\njulia> flux_DA_Nlay_cylinder_TD(1.0, 1.0, (0.1, 0.1), (10.0, 10.0))\n# for several time points\njulia> flux_DA_Nlay_cylinder_TD(0.2:0.2:2.0, 1.0, (0.1, 0.1), (10.0, 10.0))\njulia> flux_DA_Nlay_cylinder_TD([0.5, 0.8, 1.2], 1.0, (0.1, 0.1), (10.0, 10.0))\njulia> flux_DA_Nlay_cylinder_TD(0.1:0.3:5.0, 1.0, (0.1, 0.2), (12.0, 10.0), N = 48)\n# to simulate a 3 layer media\njulia> flux_DA_Nlay_cylinder_TD(0.1:0.2:1.2, 1.0, (0.2, 0.1, 0.2), (12.0, 10.0, 11.0), l = (1.0, 1.2, 4.0), n_med = (1.0, 1.0, 1.0), MaxIter=1000, atol=1.0e-8)\n\n\n\n\n\n","category":"function"},{"location":"API/#DCS","page":"API","title":"DCS","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"DAsemiinf_DCS\ng2_DA_semiinf_CW\n\nNlayer_cylinder_DCS\ng2_DA_Nlay_cylinder_CW","category":"page"},{"location":"API/#LightPropagation.Nlayer_cylinder_DCS","page":"API","title":"LightPropagation.Nlayer_cylinder_DCS","text":"NlayercylinderDCS\n\nProvides default parameters to use to compute the autocorrelation function g2 in a N-layered cylinder. The arguments defined with a Vector should be the same length and same type.\n\nKeyword Arguments\n\nρ: source-detector separation (cm⁻¹)\nμa::Vector{T}: absorption coefficient (cm⁻¹)\nμsp::Vector{T}: reduced scattering coefficient (cm⁻¹)\nn_med::Vector{T}: medium's index of refraction\nn_ext: external medium's index of refraction (air or detector)\nl: the thicknesses of each layer (cm)\nz: the z-depth orthogonal from the boundary (cm)\na: the radius of the cylinder (cm)\nβ: constant in Siegert relation dependent on collection optics\nBFi::Vector{T}: Blood flow index ~αDb (cm²/s)\nλ: wavelength (nm)\nN_J0Roots: roots of J0\n\nExamples\n\njulia> data = Nlayer_cylinder_DCS() # return default parameters\njulia> data = Nlayer_cylinder_DCS(ρ = 1.5) # return ρ = 1.5 with the rest of the parameters given by defaults\n\n# we can now define our correlation times τ\njulia> τ = 10 .^(range(-10,stop=0,length=250))\njulia> g2_DA_Nlay_cylinder_CW(τ, data)\n\n\n\n\n\n","category":"type"}]
}
