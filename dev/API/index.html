<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · LightPropagation.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LightPropagation.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../inversefitting/">Inverse Fitting</a></li><li><a class="tocitem" href="../whensemiinf/">When is semi-infinite semi-infinite?</a></li><li><a class="tocitem" href="../Nlay_tutorial/">N-layer Cylinder Examples</a></li></ul></li><li><span class="tocitem">Forward Models</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Diffusion Approximation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../DA_slab_semiinfgeom/">Slab</a></li><li><a class="tocitem" href="../Nlayer_cyl/">N-layer Cylinder</a></li><li><a class="tocitem" href="../DA_DCS/">DCS</a></li></ul></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Infinite"><span>Infinite</span></a></li><li><a class="tocitem" href="#Semi-infinite"><span>Semi-infinite</span></a></li><li><a class="tocitem" href="#Slab"><span>Slab</span></a></li><li><a class="tocitem" href="#Parallelepiped"><span>Parallelepiped</span></a></li><li><a class="tocitem" href="#Layered-Cylinder"><span>Layered Cylinder</span></a></li><li><a class="tocitem" href="#DCS"><span>DCS</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/heltonmc/LightPropagation.jl/blob/main/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Diffusion-Approximation"><a class="docs-heading-anchor" href="#Diffusion-Approximation">Diffusion Approximation</a><a id="Diffusion-Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Diffusion-Approximation" title="Permalink"></a></h1><h2 id="Infinite"><a class="docs-heading-anchor" href="#Infinite">Infinite</a><a id="Infinite-1"></a><a class="docs-heading-anchor-permalink" href="#Infinite" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.fluence_DA_inf_CW" href="#LightPropagation.fluence_DA_inf_CW"><code>LightPropagation.fluence_DA_inf_CW</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_inf_CW(ρ, μa, μsp)</code></pre><p>Compute the steady-state fluence in an infinite medium.</p><p><strong>Arguments</strong></p><ul><li><code>ρ</code>: source-detector separation (cm⁻¹)</li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; fluence_DA_inf_CW(1.0, 0.1, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Infinite/DAinfinite.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.fluence_DA_inf_TD" href="#LightPropagation.fluence_DA_inf_TD"><code>LightPropagation.fluence_DA_inf_TD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_inf_TD(t, ρ, μa, μsp; n_med = 1.0)</code></pre><p>Compute the time-domain fluence in an infinite medium.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: the time vector (ns). </li><li><code>ρ</code>: source-detector separation (cm⁻¹)</li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>n_med</code>= 1.0: medium&#39;s index of refraction</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; fluence_DA_inf_TD(0.1, 1.0, 0.1, 10.0, n_med = 1.4)
julia&gt; fluence_DA_inf_TD(0.1:0.5:5.0, 1.0, 0.1, 10.0, n_med = 1.4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Infinite/DAinfinite.jl#L46-L65">source</a></section></article><h2 id="Semi-infinite"><a class="docs-heading-anchor" href="#Semi-infinite">Semi-infinite</a><a id="Semi-infinite-1"></a><a class="docs-heading-anchor-permalink" href="#Semi-infinite" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.fluence_DA_semiinf_CW" href="#LightPropagation.fluence_DA_semiinf_CW"><code>LightPropagation.fluence_DA_semiinf_CW</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_semiinf_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0)</code></pre><p>Compute the steady-state fluence in a semi-infinite geometry.</p><p><strong>Arguments</strong></p><ul><li><code>ρ</code>: the source detector separation (cm⁻¹)</li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n_ext</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med</code>: the sample medium&#39;s index of refraction</li><li><code>z</code>: the z-depth orthogonal from the boundary (cm)</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; fluence_DA_semiinf_CW(1.0, 0.1, 10.0)
julia&gt; fluence_DA_semiinf_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, z = 0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Semi-infinite/DAsemiinf.jl#L8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.fluence_DA_semiinf_TD" href="#LightPropagation.fluence_DA_semiinf_TD"><code>LightPropagation.fluence_DA_semiinf_TD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_semiinf_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0)</code></pre><p>Compute the time-domain fluence in a semi-infinite medium.  </p><p><strong>Arguments</strong></p><ul><li><code>t</code>: the time vector (ns). </li><li><code>ρ</code>: the source detector separation (cm⁻¹)</li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n_ext</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med</code>: the sample medium&#39;s index of refraction</li><li><code>z</code>: the z-depth orthogonal from the boundary (cm)</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; fluence_DA_semiinf_TD(0.1:0.1:2.0, 1.0, 0.1, 10.0)
julia&gt; fluence_DA_semiinf_TD(0.2:0.2:1.0, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, z = 0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Semi-infinite/DAsemiinf.jl#L75-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.flux_DA_semiinf_CW" href="#LightPropagation.flux_DA_semiinf_CW"><code>LightPropagation.flux_DA_semiinf_CW</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flux_DA_semiinf_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0)</code></pre><p>Compute the steady-state flux (D*∂ϕ(ρ)/∂z @ z = 0) from a semi-infinite medium.</p><p><strong>Arguments</strong></p><ul><li><code>ρ</code>: the source detector separation (cm⁻¹)</li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>ndet</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>nmed</code>: the sample medium&#39;s index of refraction</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; flux_DA_semiinf_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Semi-infinite/DAsemiinf.jl#L31-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.flux_DA_semiinf_TD" href="#LightPropagation.flux_DA_semiinf_TD"><code>LightPropagation.flux_DA_semiinf_TD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flux_DA_semiinf_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0)</code></pre><p>Compute the time-domain flux (D*∂ϕ(t)/∂z @ z = 0) in a semi-infinite medium.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: the time vector (ns). </li><li><code>ρ</code>: the source detector separation (cm⁻¹)</li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n_ext</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med</code>: the sample medium&#39;s index of refraction</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; flux_DA_semiinf_TD(0.1:0.1:2.0, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Semi-infinite/DAsemiinf.jl#L99-L118">source</a></section></article><h2 id="Slab"><a class="docs-heading-anchor" href="#Slab">Slab</a><a id="Slab-1"></a><a class="docs-heading-anchor-permalink" href="#Slab" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.fluence_DA_slab_CW" href="#LightPropagation.fluence_DA_slab_CW"><code>LightPropagation.fluence_DA_slab_CW</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_slab_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 2.0, z = 0.0, xs = 10)</code></pre><p>Compute the steady-state fluence from a slab geometry (x, y -&gt; inf, z -&gt; finite). The fluence is calculated from an infinite summation that converges rather rapidly. Generally only 5 terms are needed (xs = 5), but more terms will be required if ρ &gt;&gt; s.</p><p><strong>Arguments</strong></p><ul><li><code>ρ</code>: the source detector separation (cm⁻¹)</li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>n_ext</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med</code>: the sample medium&#39;s index of refraction</li><li><code>s</code>: the thickness (z-depth) of the slab (cm)</li><li><code>z</code>: the z-depth within slab (cm)</li><li><code>xs</code>: the number of sources to compute in the series</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; fluence_DA_slab_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Slab/DAslab.jl#L82-L105">source</a></section><section><div><pre><code class="nohighlight hljs">fluence_DA_slab_CW(data::DiffusionParameters)</code></pre><p>Wrapper to <code>fluence_DA_slab_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0, s = 1.0, xs = 10)</code></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; data = DAslab(ρ = 1.0, s = 3.0) # use structure to generate inputs
julia&gt; fluence_DA_slab_CW(data) # then call the function</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Slab/DAslab.jl#L112-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.fluence_DA_slab_TD" href="#LightPropagation.fluence_DA_slab_TD"><code>LightPropagation.fluence_DA_slab_TD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_slab_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0, xs = 10)</code></pre><p>Compute the time-domain fluence from a slab geometry (x, y -&gt; inf, z -&gt; finite). The fluence is calculated from an infinite summation that converges rather rapidly. Generally only 5 terms are needed (xs = 5), but more terms will be required if ρ &gt;&gt; s. At long time values (low fluence values), the solution struggles with limited precision. Using double floats or BigFloats is advised at these times.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: the time vector (ns). </li><li><code>ρ</code>: the source detector separation (cm⁻¹)</li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>n_ext</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med</code>: the sample medium&#39;s index of refraction</li><li><code>s</code>: the thickness (z-depth) of the slab (cm)</li><li><code>z</code>: the z-depth coordinate (cm)</li><li><code>xs</code>: the number of sources to compute in the series</li></ul><p><strong>Examples</strong></p><p>julia&gt; <code>fluence_DA_slab_TD(0.1, 1.0, 0.1, 10.0, s = 40.0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Slab/DAslab.jl#L156-L180">source</a></section><section><div><pre><code class="nohighlight hljs">fluence_DA_slab_TD(t, data::DiffusionParameters)</code></pre><p>Wrapper to <code>fluence_DA_slab_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0, xs = 10)</code></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; data = DAslab() # use structure to generate inputs
julia&gt; fluence_DA_slab_TD(data) # then call the function</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Slab/DAslab.jl#L186-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.flux_DA_slab_CW" href="#LightPropagation.flux_DA_slab_CW"><code>LightPropagation.flux_DA_slab_CW</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_slab_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 2.0, z = 0.0, xs = 10)</code></pre><p>Compute the steady-state flux, D<em>∂ϕ(ρ)/∂z for z = 0 and -D</em>∂ϕ(ρ)/∂z for z = s from a slab geometry (x, y -&gt; inf, z -&gt; finite). If z != 0 or s will default to compute D*∂ϕ(ρ)/∂z for the z given.</p><p><strong>Arguments</strong></p><ul><li><code>ρ</code>: the source detector separation (cm⁻¹)</li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>n_ext</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med</code>: the sample medium&#39;s index of refraction</li><li><code>s</code>: the thickness (z-depth) of the slab (cm)</li><li><code>z</code>: the z-depth within slab (cm)</li><li><code>xs</code>: the number of sources to compute in the series</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; flux_DA_slab_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, s = 2.0, z = 0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Slab/DAslab.jl#L320-L342">source</a></section><section><div><pre><code class="nohighlight hljs">flux_DA_slab_CW(data::DiffusionParameters)</code></pre><p>Wrapper to <code>flux_DA_slab_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0)</code></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; data = DAslab(ρ = 1.0) # use structure to generate inputs
julia&gt; flux_DA_slab_CW(data) # then call the function</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Slab/DAslab.jl#L354-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.flux_DA_slab_TD" href="#LightPropagation.flux_DA_slab_TD"><code>LightPropagation.flux_DA_slab_TD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flux_DA_slab_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0, xs = 15)

Compute the time-domain flux, D*∂ϕ(t)/∂z for z = 0 and -D*∂ϕ(t)/∂z for z = s from a slab geometry (x, y -&gt; inf, z -&gt; finite).
If z != 0 or s will default to compute D*∂ϕ(t)/∂z for the z given.</code></pre><p><strong>Arguments</strong></p><ul><li><code>t</code>: the time vector (ns). </li><li><code>ρ</code>: the source detector separation (cm⁻¹)</li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n_ext</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med</code>: the sample medium&#39;s index of refraction</li><li><code>s</code>: the thickness (z-depth) of the slab (cm)</li><li><code>z</code>: the z-depth coordinate (cm) must be equal</li><li><code>xs</code>: the number of sources to compute in the series</li></ul><p><strong>Examples</strong></p><p>julia&gt; <code>flux_DA_slab_TD(1.0, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, z = 0.0, s = 1.0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Slab/DAslab.jl#L225-L246">source</a></section><section><div><pre><code class="nohighlight hljs">flux_DA_slab_TD(t, data::DiffusionParameters)</code></pre><p>Wrapper to <code>flux_DA_slab_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0, s = 1.0, xs = 15)</code></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; data = DAslab(ρ = 1.0) # use structure to generate inputs
julia&gt; flux_DA_slab_TD(data) # then call the function</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Slab/DAslab.jl#L257-L267">source</a></section></article><h2 id="Parallelepiped"><a class="docs-heading-anchor" href="#Parallelepiped">Parallelepiped</a><a id="Parallelepiped-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelepiped" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.fluence_DA_paralpip_CW" href="#LightPropagation.fluence_DA_paralpip_CW"><code>LightPropagation.fluence_DA_paralpip_CW</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_paralpip_CW(μa, μsp; n_ext = 1.0, n_med = 1.0, rd = [4.0, 5.0, 0.0], rs = [5.0, 5.0], L = [10.0, 10.0, 10.0], xs = 10)</code></pre><p>Compute the steady-state fluence in a parallelepiped [lx, ly, lz].</p><p><strong>Arguments</strong></p><ul><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>n_ext</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med</code>: the sample medium&#39;s index of refraction</li><li><code>rd</code>: target location within medium [x,y,z] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0</li><li><code>rs</code>: the location of the source [x,y] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0</li><li><code>L</code>: the dimensions [lx, ly, lz] of the parallelepiped</li><li><code>xs</code>: the number of sources to compute in the series</li></ul><p><strong>Examples</strong></p><p>julia&gt; <code>fluence_DA_paralpip_CW(0.1, 10.0, n_ext = 1.0, n_med = 1.0, rd = [24.0, 25.0, 0.0], rs = [25.0,25.0], L = [50.0,50.0,50.0], xs = 20)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Parallelepiped/DAparalpip.jl#L10-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.fluence_DA_paralpip_TD" href="#LightPropagation.fluence_DA_paralpip_TD"><code>LightPropagation.fluence_DA_paralpip_TD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_paralpip_TD(t, μa, μsp; n_ext = 1.0, n_med = 1.0, rd = [4.0, 5.0, 0.0], rs = [5.0, 5.0], L = [10.0, 10.0, 10.0], xs = 10)</code></pre><p>Compute the time-domain fluence in a parallelepiped [lx, ly, lz].</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: the time vector (ns). </li><li><code>μa</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp</code>: reduced scattering coefficient (cm⁻¹)</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>n_ext</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med</code>: the sample medium&#39;s index of refraction</li><li><code>rd</code>: target location within medium [x,y,z] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0</li><li><code>rs</code>: the location of the source [x,y] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0</li><li><code>L</code>: the dimensions [lx, ly, lz] of the parallelepiped</li><li><code>xs</code>: the number of sources to compute in the series</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; fluence_DA_paralpip_TD(0.5, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, rd = [24.0, 25.0, 0.0], rs = [25.0,25.0], L = [50.0,50.0,50.0], xs = 20)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/Parallelepiped/DAparalpip.jl#L82-L104">source</a></section></article><h2 id="Layered-Cylinder"><a class="docs-heading-anchor" href="#Layered-Cylinder">Layered Cylinder</a><a id="Layered-Cylinder-1"></a><a class="docs-heading-anchor-permalink" href="#Layered-Cylinder" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.fluence_DA_Nlay_cylinder_CW" href="#LightPropagation.fluence_DA_Nlay_cylinder_CW"><code>LightPropagation.fluence_DA_Nlay_cylinder_CW</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_Nlay_cylinder_CW(ρ, μa, μsp; n_ext=1.0, n_med=(1.0, 1.0), l=(1.0, 5.0), a=10.0, z=0.0, MaxIter=10000, atol=eps(Float64))</code></pre><p>Compute the steady-state fluence in an N-layered cylinder.</p><p><strong>Arguments</strong></p><ul><li><code>ρ::Union{T, NTuple{M, T}}</code>: source-detector separation(s) in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)</li><li><code>μa::NTuple{N, T}</code>: absorption coefficients in each layer (cm⁻¹)</li><li><code>μsp::NTuple{N, T}</code>: reduced scattering coefficient in each layer (cm⁻¹)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n_ext::T</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med::NTuple{N, T}</code>: the sample medium&#39;s index of refraction in each layer</li><li><code>z::T</code>: the z-depth orthogonal from the boundary (cm) within the cylinder</li><li><code>l::NTuple{N, T}</code>: layer thicknesses (cm)</li><li><code>a::T</code>: cylinder radius (cm)</li><li><code>MaxIter::Int</code>: the maximum number of terms to consider in the infinite sum</li><li><code>atol::T</code>: the infinite sum will break after this absolute tolerance is met</li></ul><p>The source must be located in the first layer (l[1] &gt; 1/μsp[1]). Other arguments are not checked but should be restricted to:</p><ul><li>ρ, μa, and z &gt;= 0.0</li><li>μsp, n<em>ext, n</em>med, a &gt; 0.0</li><li>l .&gt; 0.0</li><li>ρ &lt; a</li><li>length(μa) == length(μsp) == length(n_med) == length(l)</li></ul><p>ρ can be a single source detector separation or a tuple of separations. μa, μsp, n_med, l should be tuples of the same length (e.g., (0.1, 0.1)).  The input parameters should be of the same type, but will work with mixed types.  The routine can be accurate until the machine precision used in the calculation.  Therefore, atol should be &gt;= eps(T). Larger values of μsp[1] will require a larger number of terms in the summation. It is recommended to increase MaxIter if simulating higher scattering coefficients. It is also recommended to keep the cylinder radius as small as  possible to increase convergence rate.  </p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; fluence_DA_Nlay_cylinder_CW(1.0, (0.1, 0.1), (10.0, 10.0))
julia&gt; fluence_DA_Nlay_cylinder_CW((1.0, 2.0), (0.1, 0.1), (10.0, 10.0))
julia&gt; fluence_DA_Nlay_cylinder_CW(1.0, (0.2, 0.1), (12.0, 10.0), l = (10.0, 10.0), MaxIter=1000, atol=1.0e-8)
# to simulate a 3 layer media
julia&gt; fluence_DA_Nlay_cylinder_CW(1.0, (0.2, 0.1, 0.2), (12.0, 10.0, 11.0), l = (1.0, 1.2, 4.0), n_med = (1.0, 1.0, 1.0), MaxIter=1000, atol=1.0e-8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/DAcylinder_layered.jl#L11-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.fluence_DA_Nlay_cylinder_TD" href="#LightPropagation.fluence_DA_Nlay_cylinder_TD"><code>LightPropagation.fluence_DA_Nlay_cylinder_TD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fluence_DA_Nlay_cylinder_TD(t, ρ, μa, μsp; n_ext=1.0, n_med=(1.0, 1.0), l=(1.0, 5.0), a=10.0, z=0.0, MaxIter=10000, atol=eps(Float64), N, ILT)</code></pre><p>Compute the time-domain fluence in an N-layered cylinder.</p><p><strong>Arguments</strong></p><ul><li><code>t::Union{T, Vector{T}}</code>: time point or vector of time values (ns)</li><li><code>ρ::Union{T}</code>: source-detector separation in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)</li><li><code>μa::NTuple{N, T}</code>: absorption coefficients in each layer (cm⁻¹)</li><li><code>μsp::NTuple{N, T}</code>: reduced scattering coefficient in each layer (cm⁻¹)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n_ext::T</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med::NTuple{N, T}</code>: the sample medium&#39;s index of refraction in each layer</li><li><code>z::T</code>: the z-depth orthogonal from the boundary (cm) within the cylinder</li><li><code>l::NTuple{N, T}</code>: layer thicknesses (cm)</li><li><code>a::T</code>: cylinder radius (cm)</li><li><code>MaxIter::Int</code>: the maximum number of terms to consider in the infinite sum</li><li><code>atol::T</code>: the infinite sum will break after this absolute tolerance is met</li><li><code>N::Int</code>: the number of terms used in the integration of the trapezoidal rule for the Laplace transform</li><li><code>ILT</code>: fucntion used to perform the inverse Laplace transform</li></ul><p>The source must be located in the first layer (l[1] &gt; 1/μsp[1]). Other arguments are not checked but should be restricted to:</p><ul><li>ρ, μa, and z &gt;= 0.0</li><li>μsp, n<em>ext, n</em>med, a &gt; 0.0</li><li>l .&gt; 0.0</li><li>ρ &lt; a</li><li>length(μa) == length(μsp) == length(n_med) == length(l)</li><li>t .&gt; 0.0</li></ul><p>t can be a scaler or a vector but all values of t should be greater than zero and if a vector, should be ordered. If t is a scaler <code>hyperbola</code> is used for  the inverse Laplace transform where <code>hyper_fixed</code> is used if it is a vector. The value of N should be proportional to the dynamic range of the time-domain signal needed. If t[end]/t[1] is large then a higher value of N will be required. In general, a larger N will be needed to reconstruct very late times.  μa, μsp, n_med, l should be tuples of the same length (e.g., (0.1, 0.1)). The input parameters should be of the same type, but will work with mixed types.  The routine can be accurate until the machine precision used in the calculation.  Therefore, atol should be &gt;= eps(eltype(μsp)). Larger values of μsp[1] will require a larger number of terms in the summation. It is recommended to increase MaxIter if simulating higher scattering coefficients. It is also recommended to keep the cylinder radius as small as  possible to increase convergence rate.</p><p>The Laplace transform implements threaded parallelism. It is recommended to start Julia with multiple threads (check with Threads.nthreads() in the REPL)</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs"># at a single time point
julia&gt; fluence_DA_Nlay_cylinder_TD(1.0, 1.0, (0.1, 0.1), (10.0, 10.0))
# for several time points
julia&gt; fluence_DA_Nlay_cylinder_TD(0.2:0.2:2.0, 1.0, (0.1, 0.1), (10.0, 10.0))
julia&gt; fluence_DA_Nlay_cylinder_TD([0.5, 0.8, 1.2], 1.0, (0.1, 0.1), (10.0, 10.0))
julia&gt; fluence_DA_Nlay_cylinder_TD(0.1:0.3:5.0, 1.0, (0.1, 0.2), (12.0, 10.0), N = 48)
# to simulate a 3 layer media
julia&gt; fluence_DA_Nlay_cylinder_TD(0.1:0.2:1.2, 1.0, (0.2, 0.1, 0.2), (12.0, 10.0, 11.0), l = (1.0, 1.2, 4.0), n_med = (1.0, 1.0, 1.0), MaxIter=1000, atol=1.0e-8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/DAcylinder_layered.jl#L168-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.flux_DA_Nlay_cylinder_CW" href="#LightPropagation.flux_DA_Nlay_cylinder_CW"><code>LightPropagation.flux_DA_Nlay_cylinder_CW</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flux_DA_Nlay_cylinder_CW(ρ, μa, μsp; n_ext=1.0, n_med=(1.0, 1.0), l=(1.0, 5.0), a=10.0, z=0.0, MaxIter=10000, atol=eps(Float64))</code></pre><p>Compute the steady-state flux using Fick&#39;s law D[1]<em>∂ϕ(ρ)/∂z for z = 0 (reflectance) and -D[end]</em>∂ϕ(ρ)/∂z for z = sum(l) (transmittance) in an N-layered cylinder. z must be equal to 0 or the total length sum(l) of cylinder.</p><p><strong>Arguments</strong></p><ul><li><code>ρ::Union{T}</code>: source-detector separation in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)</li><li><code>μa::NTuple{N, T}</code>: absorption coefficients in each layer (cm⁻¹)</li><li><code>μsp::NTuple{N, T}</code>: reduced scattering coefficient in each layer (cm⁻¹)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n_ext::T</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med::NTuple{N, T}</code>: the sample medium&#39;s index of refraction in each layer</li><li><code>z::T</code>: the z-depth orthogonal from the boundary (cm) within the cylinder</li><li><code>l::NTuple{N, T}</code>: layer thicknesses (cm)</li><li><code>a::T</code>: cylinder radius (cm)</li><li><code>MaxIter::Int</code>: the maximum number of terms to consider in the infinite sum</li><li><code>atol::T</code>: the infinite sum will break after this absolute tolerance is met</li></ul><p>The source must be located in the first layer (l[1] &gt; 1/μsp[1]). Other arguments are not checked but should be restricted to:</p><ul><li>ρ, μa, and z &gt;= 0.0</li><li>μsp, n<em>ext, n</em>med, a &gt; 0.0</li><li>l .&gt; 0.0</li><li>ρ &lt; a</li><li>length(μa) == length(μsp) == length(n_med) == length(l)</li></ul><p>ρ can be a single source detector separation, however there is currently a bug in the code preventing this https://github.com/heltonmc/LightPropagation.jl/issues/11.  μa, μsp, n_med, l should be tuples of the same length (e.g., (0.1, 0.1)). The input parameters should be of the same type, but will work with mixed types.  The routine can be accurate until the machine precision used in the calculation.  Therefore, atol should be &gt;= eps(eltype(μsp)). Larger values of μsp[1] will require a larger number of terms in the summation. It is recommended to increase MaxIter if simulating higher scattering coefficients. It is also recommended to keep the cylinder radius as small as  possible to increase convergence rate.  </p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; flux_DA_Nlay_cylinder_CW(1.0, (0.1, 0.1), (10.0, 10.0))
julia&gt; flux_DA_Nlay_cylinder_CW((1.0, 2.0), (0.1, 0.1), (10.0, 10.0))
julia&gt; flux_DA_Nlay_cylinder_CW(1.0, (0.2, 0.1), (12.0, 10.0), l = (10.0, 10.0), MaxIter=1000, atol=1.0e-8)
# to simulate a 3 layer media
julia&gt; flux_DA_Nlay_cylinder_CW(1.0, (0.2, 0.1, 0.2), (12.0, 10.0, 11.0), l = (1.0, 1.2, 4.0), n_med = (1.0, 1.0, 1.0), MaxIter=1000, atol=1.0e-8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/DAcylinder_layered.jl#L92-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.flux_DA_Nlay_cylinder_TD" href="#LightPropagation.flux_DA_Nlay_cylinder_TD"><code>LightPropagation.flux_DA_Nlay_cylinder_TD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flux_DA_Nlay_cylinder_TD(t, ρ, μa, μsp; n_ext=1.0, n_med=(1.0, 1.0), l=(1.0, 5.0), a=10.0, z=0.0, MaxIter=10000, atol=eps(Float64), N, ILT)</code></pre><p>Compute the time-domain flux using Fick&#39;s law D[1]<em>∂ϕ(ρ, t)/∂z for z = 0 (reflectance) and -D[end]</em>∂ϕ(ρ, t)/∂z for z = sum(l) (transmittance) in an N-layered cylinder. ∂ϕ(ρ, t)/∂z is calculated using forward mode auto-differentiation with ForwardDiff.jl</p><p><strong>Arguments</strong></p><ul><li><code>t::Union{T, Vector{T}}</code>: time point or vector of time values (ns)</li><li><code>ρ::Union{T}</code>: source-detector separation in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)</li><li><code>μa::NTuple{N, T}</code>: absorption coefficients in each layer (cm⁻¹)</li><li><code>μsp::NTuple{N, T}</code>: reduced scattering coefficient in each layer (cm⁻¹)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n_ext::T</code>: the boundary&#39;s index of refraction (air or detector)</li><li><code>n_med::NTuple{N, T}</code>: the sample medium&#39;s index of refraction in each layer</li><li><code>z::T</code>: the z-depth orthogonal from the boundary (cm) within the cylinder</li><li><code>l::NTuple{N, T}</code>: layer thicknesses (cm)</li><li><code>a::T</code>: cylinder radius (cm)</li><li><code>MaxIter::Int</code>: the maximum number of terms to consider in the infinite sum</li><li><code>atol::T</code>: the infinite sum will break after this absolute tolerance is met</li><li><code>N::Int</code>: the number of terms used in the integration of the trapezoidal rule for the Laplace transform</li><li><code>ILT</code>: fucntion used to perform the inverse Laplace transform</li></ul><p>The source must be located in the first layer (l[1] &gt; 1/μsp[1]). Other arguments are not checked but should be restricted to:</p><ul><li>ρ, μa, and z &gt;= 0.0</li><li>μsp, n<em>ext, n</em>med, a &gt; 0.0</li><li>l .&gt; 0.0</li><li>ρ &lt; a</li><li>length(μa) == length(μsp) == length(n_med) == length(l)</li><li>t .&gt; 0.0</li></ul><p>t can be a scaler or a vector but all values of t should be greater than zero and if a vector, should be ordered. If t is a scaler <code>hyperbola</code> is used for  the inverse Laplace transform where <code>hyper_fixed</code> is used if it is a vector. The value of N should be proportional to the dynamic range of the time-domain signal needed. If t[end]/t[1] is large then a higher value of N will be required. In general, a larger N will be needed to reconstruct very late times.  μa, μsp, n_med, l should be tuples of the same length (e.g., (0.1, 0.1)). The input parameters should be of the same type, but will work with mixed types.  The routine can be accurate until the machine precision used in the calculation.  Therefore, atol should be &gt;= eps(T). Larger values of μsp[1] will require a larger number of terms in the summation. It is recommended to increase MaxIter if simulating higher scattering coefficients. It is also recommended to keep the cylinder radius as small as  possible to increase convergence rate.</p><p>The Laplace transform implements threaded parallelism. It is recommended to start Julia with multiple threads (check with Threads.nthreads() in the REPL)</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs"># at a single time point
julia&gt; flux_DA_Nlay_cylinder_TD(1.0, 1.0, (0.1, 0.1), (10.0, 10.0))
# for several time points
julia&gt; flux_DA_Nlay_cylinder_TD(0.2:0.2:2.0, 1.0, (0.1, 0.1), (10.0, 10.0))
julia&gt; flux_DA_Nlay_cylinder_TD([0.5, 0.8, 1.2], 1.0, (0.1, 0.1), (10.0, 10.0))
julia&gt; flux_DA_Nlay_cylinder_TD(0.1:0.3:5.0, 1.0, (0.1, 0.2), (12.0, 10.0), N = 48)
# to simulate a 3 layer media
julia&gt; flux_DA_Nlay_cylinder_TD(0.1:0.2:1.2, 1.0, (0.2, 0.1, 0.2), (12.0, 10.0, 11.0), l = (1.0, 1.2, 4.0), n_med = (1.0, 1.0, 1.0), MaxIter=1000, atol=1.0e-8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/DAcylinder_layered.jl#L277-L330">source</a></section></article><h2 id="DCS"><a class="docs-heading-anchor" href="#DCS">DCS</a><a id="DCS-1"></a><a class="docs-heading-anchor-permalink" href="#DCS" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DAsemiinf_DCS</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>g2_DA_semiinf_CW</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="LightPropagation.Nlayer_cylinder_DCS" href="#LightPropagation.Nlayer_cylinder_DCS"><code>LightPropagation.Nlayer_cylinder_DCS</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nlayer<em>cylinder</em>DCS</p><p>Provides default parameters to use to compute the autocorrelation function g2 in a N-layered cylinder. The arguments defined with a Vector should be the same length and same type.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>ρ</code>: source-detector separation (cm⁻¹)</li><li><code>μa::Vector{T}</code>: absorption coefficient (cm⁻¹)</li><li><code>μsp::Vector{T}</code>: reduced scattering coefficient (cm⁻¹)</li><li><code>n_med::Vector{T}</code>: medium&#39;s index of refraction</li><li><code>n_ext</code>: external medium&#39;s index of refraction (air or detector)</li><li><code>l</code>: the thicknesses of each layer (cm)</li><li><code>z</code>: the z-depth orthogonal from the boundary (cm)</li><li><code>a</code>: the radius of the cylinder (cm)</li><li><code>β</code>: constant in Siegert relation dependent on collection optics</li><li><code>BFi::Vector{T}</code>: Blood flow index ~αDb (cm²/s)</li><li><code>λ</code>: wavelength (nm)</li><li><code>N_J0Roots</code>: roots of J0</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; data = Nlayer_cylinder_DCS() # return default parameters
julia&gt; data = Nlayer_cylinder_DCS(ρ = 1.5) # return ρ = 1.5 with the rest of the parameters given by defaults

# we can now define our correlation times τ
julia&gt; τ = 10 .^(range(-10,stop=0,length=250))
julia&gt; g2_DA_Nlay_cylinder_CW(τ, data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/heltonmc/LightPropagation.jl/blob/2b4bd03b1c5b9a930bb05c659acf6f2f874fe063/src/forwardmodels/Diffusion Approximation/DCS/layered_cylinder.jl#L1-L30">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>g2_DA_Nlay_cylinder_CW</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../DA_DCS/">« DCS</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 5 November 2022 16:38">Saturday 5 November 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
