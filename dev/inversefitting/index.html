<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inverse Fitting · LightPropagation.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LightPropagation.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Inverse Fitting</a><ul class="internal"><li><a class="tocitem" href="#Steady-State"><span>Steady-State</span></a></li><li><a class="tocitem" href="#Time-Domain"><span>Time-Domain</span></a></li><li><a class="tocitem" href="#Fitting-in-layered-media"><span>Fitting in layered media</span></a></li></ul></li><li><a class="tocitem" href="../whensemiinf/">When is semi-infinite semi-infinite?</a></li></ul></li><li><span class="tocitem">Forward Models</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Diffusion Approximation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../DA_slab_semiinfgeom/">Slab</a></li><li><a class="tocitem" href="../Nlayer_cyl/">N-layer Cylinder</a></li><li><a class="tocitem" href="../DA_DCS/">DCS</a></li></ul></li></ul></li><li><a class="tocitem" href="../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Inverse Fitting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Inverse Fitting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/heltonmc/LightPropagation.jl/blob/master/docs/src/inversefitting.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Inverse-Fitting"><a class="docs-heading-anchor" href="#Inverse-Fitting">Inverse Fitting</a><a id="Inverse-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse-Fitting" title="Permalink"></a></h1><p>When dealing with experimental data, we often want to use our forward models in the inverse problem to recover quantitative data from measurements.</p><p>Here, we will walk through some basic examples to recover optical properties from both steady-state and time-domain measurements.</p><h2 id="Steady-State"><a class="docs-heading-anchor" href="#Steady-State">Steady-State</a><a id="Steady-State-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-State" title="Permalink"></a></h2><p>The first thing we want to do is simulate some experimental data. Let&#39;s do that by defining our <code>ρ</code> values and true optical properties....</p><pre><code class="language-julia hljs">julia&gt; using LightPropagation
julia&gt; ρ_arr = range(0.4, stop = 5.0, length = 10) # define our SDS we want to simulate values for
julia&gt; μa_true = 0.2; μsp_true = 10.0 # define true optical properties
julia&gt; ydata = fluence_DA_semiinf_CW.(ρ_arr, μa_true, μsp_true)</code></pre><p>One unfortunate thing is experiments usually have some noise... Let&#39;s use Noise.jl to add some multiplicative white noise with <code>stdev=0.05</code> and <code>mean=1.0</code>...</p><pre><code class="language-julia hljs">julia&gt; using Noise
julia&gt; y_noise = mult_gauss(ydata, 0.05, 1.0)</code></pre><p>Now we are ready to fit. Let&#39;s use a standard nonlinear least squares Levenberg-Marquardt algorithm with LsqFit.jl</p><pre><code class="language-julia hljs"># need to set the bounds in the inverse problem 
ub = [1.0, 50.0] # upper bound for [μa, μsp]
lb = [0.01, 3.0] # lower bound for [μa, μsp]
p0 = [0.12, 18.2] # some initial guess for our algorithm

# set up our model we want to fit with
model(ρ, β) = log10.(fluence_DA_semiinf_CW.(ρ, β[1], β[2]))</code></pre><p>The previous code block sets up the inverse problem for <code>LsqFit.jl</code>. It would be best to <a href="https://github.com/JuliaNLSolvers/LsqFit.jl">read the docs</a> of <code>LsqFit.jl</code> first. One thing we need to be careful of is properly setting up our model to fit the data. <code>LsqFit</code> needs to know for what <code>xdata</code> it is trying to fit at and for what parameters <code>β</code> it is trying to optimize for. In our case <code>β</code> is an array containing the optical properties <code>β = [μa, μsp]</code> we are seeking. It is also advantageous to fit on a log scale to better normalize the residuals at very high and low fluence values.</p><p>We are now ready to fit...</p><pre><code class="language-julia hljs">julia&gt; using LsqFit
julia&gt; fit = curve_fit(model, ρ_arr, log10.(y_noise), p0, lower=lb, upper=ub)

## Let&#39;s quickly plot our results
julia&gt; using Plots
julia&gt; scatter(ρ_arr, log10.(y_noise), xlabel = &quot;ρ (cm)&quot;, ylabel = &quot;ϕ (1/cm²)&quot;, c=:black, label = &quot;simulated data&quot;, ms=8) # with noise
julia&gt; plot!(ρ_arr, model(ρ_arr, fit.param), lw = 3, label = &quot;fit&quot;)
julia&gt; #plot!(ρ_arr, model(ρ_arr, [μa_true, μsp_true]), label = &quot;true&quot;) plots the true curve</code></pre><p><img src="../assets/inversefit_cw.png" alt="inversefit_cw"/></p><p>Note that this will take several seconds to run in the beginning due to compile times but will be faster after the first plot. We can call our fit results...</p><pre><code class="language-julia hljs">julia&gt; fit.param
2-element Vector{Float64}:
 0.2007638299707845
 9.95573558637554</code></pre><p>Sometimes we also want to randomize our initial guess. We could instead define <code>p0</code> like...</p><pre><code class="language-julia hljs">julia&gt; using Distributions
julia&gt; p0 = [rand(Uniform(lb[1], ub[1])), rand(Uniform(lb[2], ub[2]))]</code></pre><h2 id="Time-Domain"><a class="docs-heading-anchor" href="#Time-Domain">Time-Domain</a><a id="Time-Domain-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Domain" title="Permalink"></a></h2><p>A similar approach in the time-domain can occur except our <code>xdata</code> is now <code>t</code> instead of <code>ρ</code></p><pre><code class="language-julia hljs">julia&gt; t_arr = range(0.01, stop = 5.0, length = 500) # define our SDS we want to simulate values for
julia&gt; μa_true = 0.26; μsp_true = 13.0; ρ = 1.0  # define true optical properties and a single SDS
julia&gt; ydata = fluence_DA_semiinf_TD(t_arr, ρ, μa_true, μsp_true)</code></pre><p>Now, the noise in the time-domain for each bin typically follows a poisson distribution...</p><pre><code class="language-julia hljs">julia&gt; using Noise
julia&gt; y_noise = poisson(log10.(ydata), 500)

# need to set the bounds in the inverse problem 
julia&gt; ub = [1.0, 50.0] # upper bound for [μa, μsp]
julia&gt; lb = [0.01, 3.0] # lower bound for [μa, μsp]
julia&gt; p0 = [0.12, 18.2] # some initial guess for our algorithm

# set up our model we want to fit with
julia&gt; model(t, β) = log10.(fluence_DA_semiinf_TD(t, ρ, β[1], β[2]))</code></pre><p>We are now ready to fit...</p><pre><code class="language-julia hljs">julia&gt; using LsqFit
julia&gt; fit = curve_fit(model, t_arr, y_noise, p0, lower=lb, upper=ub)

## Let&#39;s quickly plot our results
julia&gt; using Plots
julia&gt; scatter(t_arr, y_noise, xlabel = &quot;ρ (cm)&quot;, ylabel = &quot;ϕ (1/cm²)&quot;, c=:black, label = &quot;simulated data&quot;, ms=8) # with noise
julia&gt; plot!(t_arr, model(t_arr, fit.param), lw = 3, label = &quot;fit&quot;)</code></pre><p><img src="../assets/inversefit_td.png" alt="inversefit_td"/></p><pre><code class="language-julia hljs">julia&gt; fit.param
2-element Vector{Float64}:
  0.2600394078015929
 12.913002920897537</code></pre><h2 id="Fitting-in-layered-media"><a class="docs-heading-anchor" href="#Fitting-in-layered-media">Fitting in layered media</a><a id="Fitting-in-layered-media-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-in-layered-media" title="Permalink"></a></h2><p>The principles described previously apply similarly to layered media where we are just increasing the number of parameters we are fitting with. Let&#39;s take for example a 2-layer media which yields potential variables of <code>μa1, μa2, μsp1, μsp2, l1, l2</code>. Now, this problem is already significantly more complex than the semi-infinite case when we were fitting for just one parameter. First, let&#39;s limit the scope to just fitting the optical properties and assume that the layer thickness are known. We can set up the problem like so...</p><pre><code class="language-julia hljs">julia&gt; t_arr = range(0.05, stop = 2.0, length = 1000)
julia&gt; ub = [1.0, 1.0, 50.0, 50.0] # upper bound for [μa1, μa2, μsp1, μsp2]
julia&gt; lb = [0.01, 0.01, 3.0, 3.0] # upper bound for [μa1, μa2, μsp1, μsp2]
julia&gt; p0 = [0.02, 0.02, 11.0, 11.0] # initial guess for [μa1, μa2, μsp1, μsp2]</code></pre><p>We can now set up our <code>ydata</code> like the following...</p><pre><code class="language-julia hljs">julia&gt; ρ = 1.0; n_med = [1.0, 1.0]; n_ext = 1.0; a = 5.0; z = 0.0
julia&gt; μa = [0.01, 0.12]
julia&gt; μsp = [8.2, 12.8]
julia&gt; l = [1.0, 4.0]
julia&gt; ydata = log10.(abs.(fluence_DA_Nlay_cylinder_TD(t_arr, ρ, μa, μsp, n_ext, n_med, l, a, z, besselroots[1:600])))</code></pre><p>One thing we need to be careful about is the fluence returning a negative value so we take the absolute value here. We can also use structures to pass arguments to the function. The next step is to set up our model but here <code>β</code> must contain an array of all our parameters...</p><pre><code class="language-julia hljs">julia&gt; model(t, β) = log10.(abs.(fluence_DA_Nlay_cylinder_TD(t, ρ, [β[1], β[2]], [β[3], β[4]], n_ext, n_med, l, a, z, besselroots[1:600])))
## we can then fit as before
julia&gt; fit = curve_fit(model, t_arr, ydata, p0, lower=lb, upper=ub)</code></pre><p>And now again we can see how the model did (with no noise)...</p><pre><code class="language-julia hljs">julia&gt; fit.param
4-element Vector{Float64}:
  0.010000000000042501
  0.12000000000000642
  8.199999999999571
 12.800000000031716</code></pre><p>So now let&#39;s say we don&#39;t know the first layer thickness....</p><pre><code class="language-julia hljs">julia&gt; t_arr = range(0.05, stop = 2.0, length = 1000)
julia&gt; ub = [1.0, 1.0, 50.0, 50.0, 4.0] # upper bound for [μa1, μa2, μsp1, μsp2, l1]
julia&gt; lb = [0.01, 0.01, 3.0, 3.0, 0.4] # upper bound for [μa1, μa2, μsp1, μsp2, l1]
julia&gt; p0 = [0.02, 0.02, 11.0, 11.0, 2.0] # initial guess for [μa1, μa2, μsp1, μsp2, l1]</code></pre><p>We can keep the same <code>ydata</code> as before but we must make our model take a fifth parameter like so...</p><pre><code class="language-julia hljs">julia&gt; model(t, β) = log10.(abs.(fluence_DA_Nlay_cylinder_TD(t, ρ, [β[1], β[2]], [β[3], β[4]], n_ext, n_med, [β[5],l[2]], a, z, besselroots[1:600])))
## we can then fit as before
julia&gt; fit = curve_fit(model, t_arr, ydata, p0, lower=lb, upper=ub)</code></pre><p>... and the results</p><pre><code class="language-julia hljs">julia&gt; fit.param
5-element Vector{Float64}:
 0.01
 0.17771692223609836
 8.232060952875878
 3.0
 1.5090937686394759</code></pre><p>Unfortunately, this did not produce very good results as this problem is significantly more difficult. We probably need to consider fitting with multiple differnet initial guesses and finding the best fit of those.... Let&#39;s try a slightly better guess...</p><pre><code class="language-julia hljs">julia&gt; p0 = [0.013, 0.16, 10.0, 15.0, 1.3]
julia&gt; fit = curve_fit(model, t_arr, ydata, p0, lower=lb, upper=ub)
julia&gt; fit.param
5-element Vector{Float64}:
 0.01
 0.12000000000085953
 8.200000000001857
 12.799999999834535
 1.0000000000043645</code></pre><p>We could also set this up as a general optimization problem like...</p><pre><code class="language-julia hljs">julia&gt; function optim_model(β, t, ydata; ρ = 1.0, l = 10.0, z = 0.0, n_ext = 1.0, n_med = [1.0, 1.0])
    ymodel = log10.(abs.(fluence_DA_Nlay_cylinder_TD(t, ρ, [β[1], β[2]], [β[3], β[4]], n_ext, n_med, [β[5],l], a, z, besselroots[1:600])))

    return sum((ydata .- ymodel).^2)
end

julia&gt; using BlackBoxOptim
julia&gt; bboptimize(β -&gt; optim_model(β, t_arr, ydata), p0; SearchRange = [(0.005, 1.0), (0.01, 1.0), (3.0, 50.0), (3.0, 50.0), (0.4, 4.0)], MaxTime = 60.0, Method = :adaptive_de_rand_1_bin)
Optimization stopped after 44479 steps and 60.00 seconds
Termination reason: Max time (60.0 s) reached
Steps per second = 741.31
Function evals per second = 743.03
Improvements/step = Inf
Total function evaluations = 44582


Best candidate found: [0.01, 0.220412, 8.17724, 3.0, 1.51944]

Fitness: 0.022200604</code></pre><p>Though, such a naive implementation does not produce great results even after a minute of optimization. </p><h3 id="Automatic-Differentiation"><a class="docs-heading-anchor" href="#Automatic-Differentiation">Automatic Differentiation</a><a id="Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation" title="Permalink"></a></h3><p>Because we do have access to gradient/jacobian information it is probably best to use it. In the previous examples using <code>LsqFit.jl</code> a central differences technique was utilized to find gradient information, however this can be significantly slower and less accurate. Let&#39;s looks at fitting layered solutions in the spatial domain using auto-diff.</p><pre><code class="language-julia hljs">julia&gt; ρ_arr = range(0.5, stop = 4.0, length = 10)
julia&gt; ub = [1.0, 1.0, 50.0, 50.0, 4.0] # upper bound for [μa1, μa2, μsp1, μsp2, l1]
julia&gt; lb = [0.01, 0.01, 3.0, 3.0, 0.4] # upper bound for [μa1, μa2, μsp1, μsp2, l1]
julia&gt; p0 = [0.02, 0.02, 11.0, 11.0, 2.0] # initial guess for [μa1, μa2, μsp1, μsp2, l1]
julia&gt; n_med = [1.0, 1.0]; n_ext = 1.0; a = 5.0; z = 0.0
julia&gt; μa = [0.01, 0.12]
julia&gt; μsp = [8.2, 12.8]
julia&gt; l = [1.0, 4.0]
julia&gt; ydata = log10.(abs.(map(ρ -&gt; fluence_DA_Nlay_cylinder_CW(ρ, μa, μsp, n_ext, n_med, l, a, z, besselroots[1:600]), ρ_arr)))

julia&gt; model(ρ_arr, β) = log10.(abs.((map(ρ -&gt; fluence_DA_Nlay_cylinder_CW(ρ, [β[1], β[2]], [β[3], β[4]], n_ext, n_med, [β[5],l[2]], a, z, besselroots[1:600]), 
ρ_arr))))
## Let&#39;s do central difference first
julia&gt; fit = curve_fit(model, ρ_arr, ydata, p0, lower=lb, upper=ub)
julia&gt; fit.param
5-element Vector{Float64}:
  0.01
  0.12000000008686881
  8.200000000444339
 12.799999996164786
  1.0000000001194502</code></pre><p>This interestingly enough produces near exact values with this initial guess... though in a slightly different setup the time-domain struggled to converge. Let&#39;s check the time to run the curve fitting...</p><pre><code class="language-julia hljs">julia&gt; @btime fit = curve_fit(model, ρ_arr, ydata, p0, lower=lb, upper=ub)
  1.961 s (240847 allocations: 102.07 MiB)</code></pre><p>So this took close to 2 seconds to run. This implementation is rather naive because we are regenerating new fluence values at each SDS from scratch which repeats a lot of similar code. Further optimizing this along with multi-threading could siginificantly decrease this time. Anyway let&#39;s see the output and benchmarks when we use autodiff instead for gradient/jacobian information...</p><pre><code class="language-julia hljs">julia&gt; @btime fit = curve_fit(model, ρ_arr, ydata, p0, lower=lb, upper=ub; autodiff=:forwarddiff)
  518.778 ms (60068 allocations: 23.80 MiB)julia&gt; fit.param
5-element Vector{Float64}:
  0.010000000014621547
  0.11999999992354275
  8.199999999622381
 12.800000003128938
  0.9999999998932497</code></pre><p>So this example take almost half a second which is ~4x faster than the central difference approach. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting Started</a><a class="docs-footer-nextpage" href="../whensemiinf/">When is semi-infinite semi-infinite? »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Monday 18 April 2022 16:05">Monday 18 April 2022</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
